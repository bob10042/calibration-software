Share


You said:
i need the correct programming sequence for the usb, rs232, and lan setup using python to correctly setup the comms and set the remote functio and the setup to read the voltages displayed on all the channells od the APSM2000 HERE IS THE COPIED PAGES FROM THE FREMOTE PROGRAMMING MANUL > M2000 SERIES OPERATION MANUAL
SECTION 10: REMOTE CONTROL
Entire Contents Copyright 2019
M2000 Series Power Analyzers Operation Manual Page 232 of 284
10
There are a great many software languages, compilers and development platforms. It is
beyond the scope of this manual to attempt to provide you with complete assistance
regarding writing software to control the M2000, so it is described in general form.
Examples provided use the Microsoft Visual Studio Express 2012 development platform and
the VB.NET language. The examples are only portions of code. In actuality, you may wish to
provide handlers for recovering from timeout errors.
The protocol used for communications is entirely ASCII based, using the commonly used
command and data fields approach although not SCPI. The same protocol is used for all
interfaces.
Note: Use of the M2000 via an interface is not dependent on the front panel being set to
any specific screen.
10.1 RS232 Serial Interface
Available settings for RS232 communication are:
Baud Rate 9600, 19200, 57600 or 115200
Handshake Bi-directional, hardware (RTS/CTS)
Data Bits 8
Parity None
Start/Stop Bits 1
Connector 9-pin Male Dsub
Interface Pinout Type DTE (same as PC computer)
Cable required 9-wire female-female null modem cable, fully wired
Cable Length < 50 ft (per standard, in practice considerably longer cable lengths are
often used without problems)
10.1.1 Connecting to the RS232 Interface
The RS232 connector located on the rear panel of the M2000 must be connected to the
computer. For a standard PC type computer this requires a 9-pin female-female null modem
o the
data and handshake lines must cross-over in the cable. Suitable cables are available from
several vendors in a selection of lengths.
Note: This cable must accommodate not only the data signals and ground, but also the
RTS, CTS and DTR signals as a minimum.
10.1.2 Using a USB to RS232 Convertor
Many computers do not have a native RS232 interface available anymore. If so, you may
need to use a USB-tosuch
convertors are commercially available but many do not have adequate performance. If
possible, use the M2000 USB interface instead.
M2000 SERIES OPERATION MANUAL
SECTION 10: REMOTE CONTROL
Entire Contents Copyright 2019
M2000 Series Power Analyzers Operation Manual Page 233 of 284
Although the use of a convertor may not appear to require the alteration of software
written by you for a direct RS232 port, the majority of USB-to-RS232 convertors have severe
latency delay (typically 10ms or more) for each transmitted and received string of
characters. In high-speed applications, this may severely restrict the overall speed. Also,
many convertors have buffers for transmitted and received characters within the convertor
itself. Experience has shown that the state of the buffer for characters transmitted from the
computer to the power analyzer is not properly managed in some convertors and can result
in buffer overrun. This can cause character loss when performing high-speed transfers of
commands to the unit. If using such a convertor and the user is experiencing data loss
(usually seen as randomly occurring command errors) then the following is recommended:
Try a different brand convertor.
Ensure you are using the latest driver for the convertor in your computer. If
changing between convertors, it is recommended to uninstall all previous USB-to-
RS232 convertor drivers after removing the present USB-to-RS232 convertor and
then rebooting the computer prior to installing a different convertor. Many different
manufacturers of convertors use a similar chip set and are detected as compatible
devices and may erroneously re-use the existing driver.
Limit all transmitted data to a maximum of 64 characters and rate limit each packet
transmitted by using pauses in your software. In extreme cases, this 64 character
limit may need to be lowered. Experience has shown that some convertors are only
reliable when single characters are transmitted. The rate limiting time delay
between packets should be greater than the USB frame rate of 1ms.
Some convertors rely on the mechanical ground connection from the RS232 end to
the convertor. Although a convertor may appear to be operating correctly, if the
screws mounting a RS232 cable to the convertor are not installed, the convertor
becomes very sensitive to interference. This typically gives a similar issue to the
buffer management issue noted above, but most often yields character loss in both
transmitted and received data.
10.1.3 Use of RS232 Control Signals
This section uses the signals names as they are present at the computer end of the cable.
The DTR signal (output from the computer) is used by the M2000 to detect that a controller
is present on the RS232 port so must be asserted for any interface activity to be recognized.
The cable used, any cable convertor used, the computer, and the software must all support
the DTR signal. If not included in the cable a disconnected DTR signal is seen by the M2000
as the absence of a computer and any characters received will be taken as interference and
discarded. If the correct DTR signal cannot be provided then a special cable can be
constructed which ties the DSR and DTR signals together, in this manner the M2000 itself
provides the DTR signal.
The DSR signal (input to the computer) is asserted by the M2000 whenever the RS232 port
of the M2000 is enabled. Generally, this signal is not used by the computer so is not often a
cause for concern.
M2000 SERIES OPERATION MANUAL
SECTION 10: REMOTE CONTROL
Entire Contents Copyright 2019
M2000 Series Power Analyzers Operation Manual Page 234 of 284
The CTS signal (input to the computer) is used by the M2000 to handshake data transmitted
from the computer and must be supported by the cable used, any cable convertor used, the
computer, and the software. Improper support for this signal is generally seen as occasional
errors in commands to the M2000 caused by command transmission corruption.
The RTS signal (output from the computer) is used by the M2000 to handshake data
transmitted from the M2000. Generally, this signal is not used by the computer so is not
often a cause for concern but it must be included in the cable as a disconnected signal
disables all data transmitted from the M2000.
10.1.4 Writing RS232 Control Software
Before your software can communicate with the M2000 it generally must create an object
for the specific serial port and configure it.
As an example the following lines of code configure and open the port for communications
(SerialPort1 is defined as a System.IO.Ports.SerialPort object):
SerialPort1.BaudRate = 115200
SerialPort1.Handshake = IO.Ports.Handshake.RequestToSend
SerialPort1.ReadTimeout = 100
SerialPort1.WriteTimeout = 100
SerialPort1.DtrEnable = True
SerialPort1.Open()
Since the M2000 communicates entirely using the standard ASCII character set, methods for
sending and receiving character strings must be used, remembering to always terminate
both transmitted and received strings with the <CR> and/or <LF> characters.
To transmit a command string (TransmitString) to the M2000 the following is an example:
SerialPort1.WriteLine(TransmitString)
To receive a response string (ReceiveString) from the M2000 the following is an example:
Dim ReceiveString as String = SerialPort1.ReadLine()
10.2 LAN (Ethernet) Interface
Available settings for LAN / Ethernet communication are:
Speed 10baseT or 100baseTX, auto-selected
Duplex Half or full-duplex, auto-selected
MDI/MDIX Auto-selected
Protocols ICMPv4, ARP, UDP/IPv4, TCP/IPv4, DHCPv4, mDNS, IGMPv3 (reducing to
v1 or v2 automatically as needed)
TCP Port 10733
Max. MTU 1500 (maximum Ethernet payload)
Remote Connections Only one remote connection is allowed at any given time
Connector RJ45
Cable required CAT5 or CAT5e, UTP or STP
Cable Length <100m (per standard)
M2000 SERIES OPERATION MANUAL
SECTION 10: REMOTE CONTROL
Entire Contents Copyright 2019
M2000 Series Power Analyzers Operation Manual Page 235 of 284
10.2.1 LAN Connection
The LAN connector located on the rear panel of the M2000 must be connected to your
network or connected to a computer either directly or through a switch (a hub is not
recommended). Standard CAT5e UTP cable is sufficient for the majority of applications and
the M2000 has auto MDI/MDIX so the use of a crossover cable is not necessary.
10.2.2 IP Addressing
Since the LAN interface of the M2000 uses IP communications, an IP address must be
assigned in some manner to the power analyzer. There are three methods of doing this as
described in section 12.3.2.3-
1. Using a manually entered IP address, gateway and subnet mask.
2. Using an IP address, gateway and subnet mask obtained from a DHCP server (all
three must be provided by the server).
3. Using an IP address obtained by the Auto-IP method (RFC3927). The IP address will
be in the range from 169.254.1.0 to 169.254.254.255.
Whichever method is used, you should note the IP address of the M2000 and use that
address to communicate with the M2000 via the LAN interface. If you use a fixed manually
entered IP, this will not change unless the manual configuration of the M2000 is changed.
However, using DHCP it may occasionally change (depending on the specific DHCP server, it
may issue the same IP address each time or it may not) and using Auto-IP it will never be the
same IP address each time that the M2000 is linked. The actual IP address of the M2000 can
be viewed by pressing the Interface Info area available on most screens and if colored
orange, it should not be used as it has not been validated. Typically, it will change to white
text within a few seconds after which it may be used.
Notes: If using Auto-IP then the traffic to and from the M2000 should not be able to pass
through a router, so the M2000 must be local to the computer.
If using DHCP or Auto-IP then it may take some time to obtain a valid IP address
after attachment to the network. This typically takes a few seconds, but can
occasionally take considerably longer.
The M2000 does not support generating VLAN traffic, and although it can receive
VLAN formatted traffic it ignores the VLAN information. If used on a network which
uses VLAN then it should be located on a portion of that network which does not
have the VLAN content. Check with your IT department regarding this if necessary.
10.2.3 LAN Security Concerns
You may be concerned with the security of your network when connecting a M2000 to it.
Such a concern is generally unwarranted as the M2000 is not capable of any transfers that
can detrimentally affect other equipment or computers on the network.
Additionally, the M2000 can be configured for Auto-IP (RFC3927) IP addressing. In that case,
no traffic to or from the M2000 should be able to pass through a router, so the M2000 can
be made local to a portion of a network.
M2000 SERIES OPERATION MANUAL
SECTION 10: REMOTE CONTROL
Entire Contents Copyright 2019
M2000 Series Power Analyzers Operation Manual Page 236 of 284
Note: The M2000 generally has a benign presence on the LAN and does not broadcast any
traffic related to its presence on the LAN (other than DHCP traffic if enabled and
ARP traffic as needed).
The M2000 only supports:
The DHCP Protocol (only if configured to use DHCP).
The ARP protocol (only to ensure the uniqueness of its own IP address, and as
necessary to confirm the presence of the computer which has a TCP/IP socket
established to the M2000. The M2000 does not arbitrarily generate ARP requests).
If the M2000 is configured to have an IDENTITY name, then this is verified as being
unique using mDNS when the M2000 is turned on, or just connected to the LAN, or
the identity name is changed. The identity capability may be disabled to remove the
capability of generating mDNS traffic.
Transfer of ASCII data from the M2000 to a computer using streaming TCP/IP
protocol to which it has a TCP/IP socket established only when and as directed by
that computer (only a single socket is allowed by the M2000). Data transmitted
from the M2000 can only be measurement results and measurement status
information. These are all non-broadcast datagrams, so in a well-designed network
these datagrams will not be transmitted beyond the connection between the
computer and the M2000.
All LAN packets received that are not supported are silently discarded and ignored.
The M2000 does not support:
Communications with a computer with which it does not have a TCP/IP socket
established (which can only be established by the computer, not by the M2000).
Reception of any broadcast requests other than DHCP (only if enabled) and ARP (all
other received broadcasts are silently ignored).
Transmission of any broadcast packets other than DHCP (only if enabled) and ARP
(only as required to ensure the uniqueness of its own IP address).
Transporting any binary data.
Any network management protocols such as SNMP, SSDP, LLDP, SDP, CDP etc., or
routing protocols such as RIP etc.
M2000 via the LAN.
Any POP, SMTP, IMAP, NetBIOS, NetBT, IPX or similar protocols that can establish a
connection to another computer.
10.2.4 Writing LAN Control Software
All communication with the M2000 uses TCP/IP port 10733 on the M2000. The M2000 only
allows one active socket at any given time, so you should close the TCP/IP socket when
finished using it. To avoid unnecessary lockouts, the M2000 will allow a replacement socket
if the previously active socket is still open but has not been active for >1 minute. In this case,
M2000 SERIES OPERATION MANUAL
SECTION 10: REMOTE CONTROL
Entire Contents Copyright 2019
M2000 Series Power Analyzers Operation Manual Page 237 of 284
it will close the expired socket (this only occurs if a new socket is attempted, otherwise the
M2000 will keep a socket open even if it is not active).
TCP/IP has CRC error checking, packet loss detection, and automatic retransmission of lost
or corrupted data. This means that the user need not perform error checking using
commands such as *ERR? when using the LAN interface except for testing your software, as
each command is guaranteed to reach the M2000 without error.
Before your software can communicate with the M2000 it generally must create an object
for the socket and then configure and open it.
Dim enet_socket As System.Net.Sockets.TcpClient
enet_socket.Connect(System.Net.IPAddress.Parse(EnetIPAddrBox.Text),
10733) enet_socket.ReceiveTimeout = 1000
To close the socket the following is an example.
enet_socket.Close()
The example above shows using the IP address of a M2000 to open a connection to it.
Alternatively the identity name of the M2000 can used,
end of it, as an example if the M2000 identity is M2000-123456 then a socket with it can be
opened using:
-
Opening a socket using the identity name has the advantage that you do not need to know
modified to accommodate changes to the network configuration.
Since the M2000 communicates entirely using the standard ASCII character set, methods for
sending and receiving character strings must be used, remembering to always terminate
both transmitted and received strings with the <CR> and/or <LF> characters.
To transmit a command string (TransmitString) to the M2000 the following is an example:
Dim send_data As Byte() = System.Text.Encoding.ASCII.GetBytes
( TransmitString + Chr(10))
Dim send_len As Integer = cmd_string.Length
enet_socket.GetStream.Write(send_data, 0, send_len + 1)
To receive a response string (ReceiveString) from the M2000 the following is an example:
Dim sr As New System.IO.StreamReader(enet_socket.GetStream())
Dim ReceiveString as String = sr.ReadLine()
10.3 USB Interface
Available settings for USB communication are:
Connector USB B connector
Cable required USB 2.0 A-B Cable
Compatibility Compatible with Windows XP and later operating systems
USB Speed Full-speed
USB Device Enumerates as a Human Interface Device (HID) of the Vendor-specific
type
M2000 SERIES OPERATION MANUAL
SECTION 10: REMOTE CONTROL
Entire Contents Copyright 2019
M2000 Series Power Analyzers Operation Manual Page 238 of 284
Driver None required
10.3.1 USB Connection
The USB connector located on the rear panel of the M2000 must be connected to the
computer or a hub using a standard USB AB type cable. The use of a quality cable is
particularly recommended if interference is likely, as lower quality cables have poor
shielding (if any) and have a high RF impedance in the ground connection.
The M2000 does not require a vendor supplied driver, so no installation is required. When
the M2000 is first connected to a computer (sometimes to each specific USB port of a
computer), the operating system of the computer must load its native HID device driver.
This may take a short while. During that time, the M2000 cannot be communicated with via
the USB. The M2000 appears as a standard HID Input Device with Vendor-specific
properties. It is shown in the Windows Device Manager as a Human Interface Device -> USB
Input Device.
10.3.2 Writing USB Control Software
Since the M2000 appears as a standard HID Device with Vendor-specific properties, you
must communicate through the standard Windows® interface for such devices. This can be a
difficult task, so a pair of DLL files to ease this communication (SLABHIDtoUART.dll and
SLABHIDDevice.dll are provided. Both of these must be accessible to your program).
All attempts to open the port, transmit strings through the port, receive strings through the
port and close the port should be directly made through simple calls to these DLL files.
Header files defining these calls for VB.NET, for C# and for C/C++ are also provided
(SLABCP2110.vb, SLABCP2110.cs and SLABCP2110.h respectively).
When compiling applications using the Visual Studio development platform you should
compile for x86 processors otherwise there may be conflicts with the supplied DLL files.
Note that most communications require knowledge of the USB VID (Vendor ID) and PID
(Product ID) numbers used by the M2000. These are 4292 and 34869 respectively for all
M2000 units.
Before your software can communicate with the M2000 it generally must create an object
for the socket and then configure and open it.
Dim num_devices As Integer
Dim usbdevice As System.IntPtr
HidUart_GetNumDevices(num_devices, 4292, 34869)
If (num_devices > 0 And HidUart_Open(usbdevice, 0, 4292, 34869) =
HID_UART_SUCCESS) Then HidUart_SetUartConfig(usbdevice, 115200,
HID_UART_EIGHT_DATA_BITS, HID_UART_NO_PARITY, /
ID_UART_SHORT_STOP_BIT, HID_UART_RTS_CTS_FLOW_CONTROL)
HidUart_SetTimeouts(usbdevice, 0, 1000)
End If
To close the connection the following is an example.
HidUart_Close(usbdevice)
M2000 SERIES OPERATION MANUAL
SECTION 10: REMOTE CONTROL
Entire Contents Copyright 2019
M2000 Series Power Analyzers Operation Manual Page 239 of 284
Since the M2000 communicates entirely using the standard ASCII character set, methods for
sending and receiving character strings must be used, remembering to always terminate
both transmitted and received strings with the <CR> and/or <LF> characters.
Although not shown here, you should check if the device handle is active by using the
HidUart_IsOpened function call prior making calls for transmitting or receiving data. If this
call indicates an invalid handle then you should repeat the process of opening a socket and
obtaining a new device handle. This is only needed when significant interference is present
and is necessary because some operating systems (e.g. Windows) disconnect a USB device
which has interference.
To transmit a command string (TransmitString) to the M2000 the following is an example:
Dim send_data As Byte() = System.Text.Encoding.ASCII.GetBytes
(cmd_string + Chr(10))
Dim send_len As Integer = cmd_string.Length
Dim written As Integer
HidUart_Write(usbdevice, send_data, send_len + 1, written)
To receive a response string (ReceiveString) from the M2000 the following is an example
' The USB only operates with byte arrays - so must handle each byte
' and detect the LF terminator
' Although usually all characters in a response are received in a
' single array, this cannot be ' relied upon
' Uses a 2 second timeout to receive a complete line (far longer than
' needed)
Dim Timer As Stopwatch = Stopwatch.StartNew()
Dim rx_lf As Boolean = False
While (Not (rx_lf))
Dim rx_data(1024) As Byte
Dim rx_index As Integer = 0
Dim bytes As Integer = 0
HidUart_Read(usbdevice, rx_data, 1024, bytes)
' Because we configured a 0 read timeout this will return
' characters
While (bytes)
If (rx_data(rx_index) = 10)
Then rx_lf = True
Exit While
End If
rx_index += 1
bytes -= 1
End While
ReceiveString += System.Text.Encoding.ASCII.GetString(rx_data,
0, rx_index)
If (Timer.ElapsedMilliseconds > 2000) Then
' Timeout occurred need to take some action here
Timer.Stop()
Exit Function
End If
End While
M2000 SERIES OPERATION MANUAL
SECTION 10: REMOTE CONTROL
Entire Contents Copyright 2019
M2000 Series Power Analyzers Operation Manual Page 240 of 284
10.3.3 Summary of provided USB Support DLL Functions
In all function calls requiring a PID and/or VID, you must use the values noted above for the
M2000. The definitions for the function shown below use a C language form for clarity. DO
NOT use the calls exactly as shown here. Instead, use the header provided for the specific
language being used.
CAUTION: The provided DLL files also contain other functions, you must not call these
other functions, otherwise it may render the M2000 permanently inoperative.
HidUart_GetNumDevices
This function returns the number of devices connected to the host with matching vendor and
product ID (VID, PID).
HID_UART_STATUS HidUart_GetNumDevices (DWORD* numDevices, WORD vid, WORD pid)
numDevices Returns the number of devices connected on return.
vid Filter device results by vendor ID.
pid Filter device results by product ID.
Return Value: HID_UART_STATUS = HID_UART_SUCCESS, HID_UART_INVALID_PARAMETER
HidUart_GetString
This function returns a null-terminated vendor ID string, product ID string, serial string, device
path string, manufacturer string, or product string for the device specified by an index passed in
deviceNum. The index for the first device is 0 and the last device is the value returned by
HidUart_GetNumDevices() 1.
HID_UART_STATUS HidUart_GetString (DWORD deviceNum, WORD vid, WORD pid, char*
deviceString, DWORD options)
deviceNum Index of the device for which the string is desired.
vid Filter device results by vendor ID.
pid Filter device results by product ID.
deviceString Variable of type HID_UART_DEVICE_STRING which will contain a NULL terminated
ASCII device string on return. The string is 260 bytes.
options Determines if deviceString contains a vendor ID string, product ID string, serial string,
device path string, manufacturer string, or product string.
Return Value: HID_UART_STATUS = HID_UART_SUCCESS, HID_UART_DEVICE_NOT_FOUND,
HID_UART_INVALID_PARAMETER, HID_UART_DEVICE_ACCESS_ERROR
HidUart_GetOpenedString
This function returns a null-terminated vendor ID string, product ID string, serial string, device
path string, manufacturer string, or product string for the device specified by device.
HID_UART_STATUS HidUart_GetOpenedString (HID_UART_DEVICE device, char* deviceString,
DWORD options)
device Device object pointer as returned by HidUart_Open().
deviceString Variable of type HID_UART_DEVICE_STRING which will contain a NULL terminated
ASCII device string on return. The string is 260 bytes.
options Determines if deviceString contains a vendor ID string, product ID string, serial string,
device path string, manufacturer string, or product string.
Return Value: HID_UART_STATUS = HID_UART_SUCCESS, HID_UART_INVALID_DEVICE_OBJECT,
HID_UART_INVALID_PARAMETER, HID_UART_DEVICE_ACCESS_ERROR
HidUart_Open
M2000 SERIES OPERATION MANUAL
SECTION 10: REMOTE CONTROL
Entire Contents Copyright 2019
M2000 Series Power Analyzers Operation Manual Page 241 of 284
Opens a device using a device number between 0 and HidUart_GetNumDevices() 1 and returns a
device object pointer which will be used for subsequent accesses.
HID_UART_STATUS HidUart_Open (HID_UART_DEVICE* device, DWORD deviceNum, WORD vid,
WORD pid)
device Returns a pointer to a M2000 device object. This pointer will be used by all subsequent
accesses to the device.
deviceNum Zero-based device index, between 0 and (HidUart_GetNumDevices() 1).
vid Filter device results by vendor ID.
pid Filter device results by product ID.
Return Value: HID_UART_STATUS= HID_UART_SUCCESS, HID_UART_INVALID_DEVICE_OBJECT,
HID_UART_DEVICE_NOT_FOUND, HID_UART_INVALID_PARAMETER,
HID_UART_DEVICE_IO_FAILED, HID_UART_DEVICE_ACCESS_ERROR,
HID_UART_DEVICE_NOT_SUPPORTED
Note - Be careful when opening a device. Any HID device may be opened by this library.
However, if the device is not actually a M2000, use of this library will cause undesirable results.
The M2000 PID and VID must always be used.
HidUart_Close
Closes an opened device using the device object pointer provided by HidUart_Open().
HID_UART_STATUS HidUart_Close (HID_UART_DEVICE device)
device Device object pointer as returned by HidUart_Open().
Return Value: HID_UART_STATUS= HID_UART_SUCCESS, HID_UART_INVALID_DEVICE_OBJECT,
HID_UART_INVALID_HANDLE, HID_UART_DEVICE_ACCESS_ERROR
Note: - device is invalid after calling HidUart_Close(). It is recommended to set device to NULL
after this call.
HidUart_IsOpened
Returns the device opened status.
HID_UART_STATUS HidUart_IsOpened (HID_UART_DEVICE device, BOOL* opened)
device Device object pointer as returned by HidUart_Open().
opened Returns TRUE if the device object pointer is valid and the device has been opened using
HidUart_Open().
Return Value: HID_UART_STATUS= HID_UART_SUCCESS, HID_UART_INVALID_DEVICE_OBJECT,
HID_UART_INVALID_PARAMETER
HidUart_Read
Reads the available number of bytes into the supplied buffer and returns the number of bytes
read which can be less than the number of bytes requested. This function returns synchronously
after reading the requested number of bytes or after the timeout duration has elapsed. Read and
write timeouts can be set using HidUart_SetTimeouts().
HID_UART_STATUS HidUart_Read (HID_UART_DEVICE device, BYTE* buffer, DWORD
numBytesToRead, DWORD* numBytesRead)
device Device object pointer as returned by HidUart_Open().
buffer Address of a buffer to be filled with read data.
numBytesToRead Number of bytes to read from the device into the buffer (1 32768). This
value must be less than or equal to the size of buffer.
numBytesRead Returns the number of bytes actually read into the buffer on completion.
M2000 SERIES OPERATION MANUAL
SECTION 10: REMOTE CONTROL
Entire Contents Copyright 2019
M2000 Series Power Analyzers Operation Manual Page 242 of 284
Return Value: HID_UART_STATUS = HID_UART_SUCCESS, HID_UART_READ_ERROR,
HID_UART_INVALID_PARAMETER, HID_UART_INVALID_DEVICE_OBJECT,
HID_UART_READ_TIMED_OUT, HID_UART_INVALID_REQUEST_LENGTH
Note: - HidUart_Read() returns HID_UART_READ_TIMED_OUT if the number of bytes read is less
than the number of bytes requested. This will only occur after the read timeout has
elapsed. If the number of bytes read matches the number of bytes requested, this
function will return HID_UART_SUCCESS.
HidUart_Write
Write the specified number of bytes from the supplied buffer to the device. This function returns
synchronously after writing the requested number of bytes or after the timeout duration has
elapsed. Read and write timeouts can be set using HidUart_SetTimeouts().
HID_UART_STATUS HidUart_Write (HID_UART_DEVICE device, BYTE* buffer, DWORD
numBytesToWrite, DWORD* numBytesWritten)
device Device object pointer as returned by HidUart_Open().
buffer Address of a buffer to be sent to the device.
numBytesToWrite Number of bytes to write to the device (1 4096 bytes). This value must be
less than or equal to the size of buffer.
numBytesWritten Returns the number of bytes actually written to the device.
Return Value: HID_UART_STATUS = HID_UART_SUCCESS, HID_UART_WRITE_ERROR,
HID_UART_INVALID_PARAMETER, HID_UART_INVALID_DEVICE_OBJECT,
HID_UART_WRITE_TIMED_OUT, HID_UART_INVALID_REQUEST_LENGTH
Note:- HidUart_Write() returns HID_UART_WRITE_TIMED_OUT if the number of bytes written is
less than the number of bytes requested.
HidUart_FlushBuffers
This function flushes the receive buffer in the M2000 and the HID driver.
HID_UART_STATUS HidUart_FlushBuffers (HID_UART_DEVICE device, BOOL flushTransmit, BOOL
flushReceive)
device Device object pointer as returned by HidUart_Open().
flushTransmit Set to TRUE to flush the device transmit buffer.
flushReceive Set to TRUE to flush the device receive buffer and HID receive buffer.
Return Value: HID_UART_STATUS = HID_UART_SUCCESS, HID_UART_INVALID_DEVICE_OBJECT,
HID_UART_DEVICE_IO_FAILED
HidUart_Cancello
This function cancels any pending HID reads and writes.
HID_UART_STATUS HidUart_CancelIo (HID_UART_DEVICE device)
device Device object pointer as returned by HidUart_Open().
Return Value: HID_UART_STATUS = HID_UART_SUCCESS, HID_UART_INVALID_DEVICE_OBJECT,
HID_UART_DEVICE_IO_FAILED
HidUart_SetTimeouts
Sets the read and write timeouts. Timeouts are used for HidUart_Read() and HidUart_Write().
The default value for timeouts is 1000 ms, but timeouts can be set to wait for any number of
milliseconds between 0 and 0xFFFFFFFF.
HID_UART_STATUS HidUart_SetTimeouts (HID_UART_DEVICE device, DWORD readTimeout,
DWORD writeTimeout)
device Device object pointer as returned by HidUart_Open().
M2000 SERIES OPERATION MANUAL
SECTION 10: REMOTE CONTROL
Entire Contents Copyright 2019
M2000 Series Power Analyzers Operation Manual Page 243 of 284
readTimeout HidUart_Read() operation timeout in milliseconds.
writeTimeout HidUart_Write() operation timeout in milliseconds.
Return Value: HID_UART_STATUS = HID_UART_SUCCESS, HID_UART_INVALID_DEVICE_OBJECT
Note: - If read timeouts are set to a large value and no data is received, then the application may
appear unresponsive. It is recommended to set timeouts appropriately before using the
device.
HidUart_SetUartConfig
Sets the baud rate, data bits, parity, stop bits, and flow control. Caution, this sets parameters
within the M2000 do NOT alter these settings from those shown below.
HidUart_SetUartConfig(device, 115200, HID_UART_EIGHT_DATA_BITS, HID_UART_NO_PARITY,
HID_UART_SHORT_STOP_BIT, HID_UART_RTS_CTS_FLOW_CONTROL)
device Device object pointer as returned by HidUart_Open().
Return Value: HID_UART_STATUS = HID_UART_SUCCESS, HID_UART_INVALID_PARAMETER,
HID_UART_INVALID_DEVICE_OBJECT, HID_UART_DEVICE_IO_FAILED
10.4 Command Syntax
All commands to the M2000 use the standard 7-bit ASCII character set using 8-bit encoding
(the 8th bit is zero), independent of the actual interface being used. A command is a stream
of characters.The M2000 stores received characters until a command terminator character
is received and only then is action taken on the commands. Further characters may be
received while the M2000 is taking the actions needed complete a preceding command but
no action will be taken on them until all pending command decode activity is completed.
Each command is a KEYWORD field defining the command, possibly followed by further
fields that refine the action of the command. The available command keywords and the
fields required for each are described in tables later in this section.
More than one command can be present in a single command set. In that case, each
command must be separated from the previous by a command separator character. If an
error is found in any command within a command set, that command and any remaining
commands which follow it in the command set will not be executed.
Since the interface is based on streaming ASCII characters, the use of separator and
terminator characters is required to ensure that the extents of each field can be established.
To improve the readability of commands you may also wish to employ whitespace
characters to spread apart fields.
10.4.1 Special Characters
Certain ASCII characters serve a special purpose as described below.
COMMAND TERMINATOR CHARACTERS
The end of a command set is determined by the presence of a command terminator
which may be the line-feed, carriage return, form feed or NULL (0 value) ASCII
characters.
Everything between successive command terminators is a command set. A command
set is limited to a maximum of 4095 characters in total. There is no action taken or error
M2000 SERIES OPERATION MANUAL
SECTION 10: REMOTE CONTROL
Entire Contents Copyright 2019
M2000 Series Power Analyzers Operation Manual Page 244 of 284
generated if a command terminator is immediately followed by another command
terminator.
COMMAND SEPARATOR CHARACTER
If more than one command is in a command set then each successive command is
separated from the previous by a command separator, which is the semi-colon ASCII
character (;).
Everything between successive command separators or command terminators is a
command. There is no action taken or error generated if a command separator is
immediately followed by another command separator or a command terminator.
FIELD SEPARATOR CHARACTER
Most commands require command fields which refine the action of the command; each
field is separated from the previous by a field separator which is the comma ASCII
character (,).
Everything between successive field separators, command separators or command
terminators is a field.
SUB-FIELD SEPARATOR CHARACTER
In some cases a single command field is made up of several sub-fields; each sub-field is
separated from a previous sub-field by a sub-field separator, which is the colon ASCII
character (:).
Everything between successive sub-field separators, field separators, command
separators or command terminators is a sub-field.
WHITESPACE CHARACTERS
Most fields and sub-fields can have one or more whitespace characters at the beginning
and/or end. The space, tab and underscore ASCII characters are considered as
whitespace characters.
10.4.2 Command Fields
Command fields are one of the types described below. In certain cases, a single field may be
formed by multiple sub-fields, in which case each successive sub-field (each having one of
the field types described below) is separated from the previous by a preceding sub-field
separator character.
KEYWORD COMMAND FIELD SYNTAX
A KEYWORD field is a combination of printable ASCII characters which match the
corresponding allowable keywords as described later. A KEYWORD field is not casesensitive
(e.g. the letters V and v are equivalent) and may be preceded and/or followed
by one or more whitespace characters but may not contain any whitespace characters
within it.
Examples of valid KEYWORD fields are:
M2000 SERIES OPERATION MANUAL
SECTION 10: REMOTE CONTROL
Entire Contents Copyright 2019
M2000 Series Power Analyzers Operation Manual Page 245 of 284
*CLS *cls *Cls
ARANGE Arange
CH1 Ch1 ch1
STRING COMMAND FIELD SYNTAX
string. However, certain characters have special meaning:
acter
\ The ø character
[ The up arrow character
 The down arrow character
] The ° character
Note: STRING fields are only terminated by a command terminator or separator
character and may contain what would normally be any other separator
character (if printable).
Examples of valid STRING fields are:
This is a string field
Volts:
NR1 COMMAND FIELD SYNTAX
A NR1 field is any combination of ASCII numeric (0 through 9) characters which form an
integer value. A NR1 command field must not include a polarity character. A NR1 field
may be preceded and/or followed by one or more whitespace characters but may not
contain any whitespace characters within it.
All NR1 fields must be in the range 0 to 4294967295 and will cause a syntax error if
outside of this range and in most commands this range is further limited and will cause a
data range error if that range is exceeded.
Examples of valid NR1 fields are:
10
153465782
NR3 COMMAND FIELD SYNTAX
A NR3 field is any combination of ASCII characters which form a floating point value. A
NR3 field may be preceded and/or followed by one or more whitespace characters but
may not contain any whitespace characters within it.
All NR3 fields are decoded and used within the M2000 with approximately 1 in 107
resolution and may be in the range -10+99 to 10+99 and may contain a number of
characters which is only limited by the maximum length of a command set.
Examples of valid NR3 fields are:
M2000 SERIES OPERATION MANUAL
SECTION 10: REMOTE CONTROL
Entire Contents Copyright 2019
M2000 Series Power Analyzers Operation Manual Page 246 of 284
10
10.0
+10.0
1e1
-10.0
+1.2345678E+6
+1.2345678e+6
+1.2345678e-6
+1.2345678e6
153465782.34
VDEF COMMAND FIELD SYNTAX
This field type allows you to define a VPA using any one of the following syntaxes-
1 to 3 NR1 syntax
A1 to A3 KEYWORD syntax
VPA1 to VPA3 KEYWORD syntax
CH1 to CH4 KEYWORD syntax, defines the VPA which is presently configured to
use the channel identified by CH1 to CH4; some commands do not
support this syntax within a VDEF field
CDEF COMMAND FIELD SYNTAX
This field type allows you to define a channel using any one of the following syntaxes:
1 to 4 NR1 syntax
CH1 to CH4 KEYWORD syntax
RDEF COMMAND FIELD SYNTAX
This field type contains 1 to 5 sub-fields which define a measurement result to be used.
See a later section for details regarding the sub-fields of the RDEF command field type.
DDEF COMMAND FIELD SYNTAX
This field type contains 1 to 5 sub-fields which define a measurement result to be used.
See a later section for details regarding the sub-fields of the DDEF command field type.
COLOR COMMAND FIELD SYNTAX
A COLOR command field contains three NR1 type sub-fields defining the level of the red,
green and blue color components respectively. Each value is a maximum of 255
corresponding to full brightness of the respective color.
BLANK COMMAND FIELD SYNTAX
In some cases it is allowed to have a blank command field. This is a field which has a
preceding field separator character but is immediately followed by another separator or
terminator character. Except for a STRING command field, a blank field may contain one
or more whitespace characters but no other characters.
M2000 SERIES OPERATION MANUAL
SECTION 10: REMOTE CONTROL
Entire Contents Copyright 2019
M2000 Series Power Analyzers Operation Manual Page 247 of 284
10.4.3 Command Responses
Some commands cause the M2000 to respond with a requested data response or set of data
responses. The response is formed by a set of fields, similar to those for commands
described above.
Note: All command keywords which end with the ? character cause a response. All
command keywords which do not end with the ? character do not cause a response.
All responses from the M2000 use the standard 7-bit ASCII character set using 8-bit
encoding (the 8th bit is zero) independent of the actual interface being used.
You may request more than one response in a set of commands. In this case, each response
(or set of responses) is separated from the previous by a comma separator and the
responses are included in the same order as they were requested. A complete response is
always terminated by a carriage return followed by a line feed ASCII character and may
contain up to 65535 characters in total.
It is expected that after a command is given to the unit to produce a response, the
originator will not issue further commands requesting a response until that prior response
has been fully received. If the unit receives a command which requests a response but the
prior response has not been fully transmitted, it this raises a Tx Overrun error.
As defined for each such command a response is one or more fields, each of which is of the
following types:
STRING RESPONSE FIELD SYNTAX
A STRING response is a set of ASCII characters forming the response. Only printable
ASCII characters are used and the length of a STRING response is variable, the
terminating comma (if more response fields follow it) or the terminating carriage return
and line feed characters should be used to determine the end of a STRING field.
NR1 RESPONSE FIELD SYNTAX
A NR1 response is a set of ASCII numeric characters defining an integer value. The length
of a NR1 response is variable, the terminating comma (if more response fields follow it)
or the terminating carriage return and line feed characters should be used to determine
the end of a NR1 field. A NR1 response never includes a polarity symbol, as all such
responses are positive.
NR3 RESPONSE FIELD SYNTAX
A NR3 response is a set of ASCII characters defining a floating-point numeric value. The
length of a NR3 response is fixed at 11 characters however it is recommended that the
terminating comma (if more response fields follow it) or the terminating carriage return
and line feed characters be used to determine the end of a NR3 field.
A NR3 response always has the following parts in the order shown:
A polarity character, defining the polarity of the numeric 6 digit characters with
an embedded decimal point character, defining the mantissa portion of the
numeric
M2000 SERIES OPERATION MANUAL
SECTION 10: REMOTE CONTROL
Entire Contents Copyright 2019
M2000 Series Power Analyzers Operation Manual Page 248 of 284
The letter E character (upper case)
A polarity character, defining the polarity of the exponent
A single digit character defining the exponent (which is always a multiple of 3)
Note: There is a special case of a NR3 response used to indicate that the data is not
available. Normally a zero value uses a +0.00000E-9 response; a response of
+0.00000E+0 indicates that the value is unavailable.
10.5 Command Keywords and Fields
In the tables below, the specified command KEYWORD should be followed by each field (if
any) in the order described in the table with each field separated from the previous by a
field separator character. E.g. VSCALE,1,0 turns off voltage scaling for channel 1.
Notes: For clarity, each command within each section is listed in alphabetical order and all
tables listing those commands have the same column usage.
Where the FIELD(s) column indicates a dash (-) then that command requires no
fields.
Where the FIELD(s) column indicates that fields are required, then those fields must
be included with the command in the order shown in the table.
10.5.1 Interface Clear Commands
Both of these commands perform the same function. The use of either of these commands
is recommended when starting a session with the M2000 to ensure that any incomplete
activities performed in a prior session are properly discarded.
COMMAND
KEYWORD
FIELD(s) FIELD
FORMAT
FIELD DATA
RANGE
DESCRIPTION
*CLS - - - Clears all interface registers and flushes any unsent Tx data,
selects the LOCAL state, and abandons any unsaved
measurement configuration changes from *RST the interface
10.5.2 Local / Remote State Control Commands
The M2000 automatically enters the REMOTE state when any command is received via an
interface. While in the REMOTE state a front panel user cannot change the measurement or
interface configuration without first selecting to return to the LOCAL state. Interface
commands are always actioned independent of the LOCAL/REMOTE state. These commands
are invalid commands if received via the GPIB interface.
COMMAND
KEYWORD
FIELD(s) FIELD
FORMAT
FIELD DATA
RANGE
DESCRIPTION
LOCAL - - - Enters the LOCAL state (front panel measurement configuration
changes enabled)
LOCKOUT - - - Enters the LOCKOUT state (front panel measurement
configuration changes disabled and you cannot unlock from the
front panel)
M2000 SERIES OPERATION MANUAL
SECTION 10: REMOTE CONTROL
Entire Contents Copyright 2019
M2000 Series Power Analyzers Operation Manual Page 249 of 284
10.5.3 Unit and Channel Identification Commands
COMMAND
KEYWORD
FIELD(s) FIELD
FORMAT
FIELD DATA
RANGE
DESCRIPTION
CHNL? c CDEF - Responds with two fields describing channel c -
1st field: (STRING) Two letter channel type (or NF if not fitted, or
NI if fitted but has invalid data)
2nd field: (NR1) Serial Number
IDENT? - - - Responds with the STRING identity name configured for this
M2000.
*IDN? - - - Responds with six fields describing the M2000 as follows -
1st field: (STRING) Manufacturer
2nd field: (STRING) Model (with /H500/EN/MU appended if the
respective option is installed)
3rd field: (STRING) Unit serial number
4th field: (NR1) Firmware major version number
5th field: (NR1) Firmware minor version number
6th field: (NR1) Firmware build number
10.5.4 Error Register Query Commands
Each register accumulates interface command errors and is cleared when read. The use of
the ERR register is recommended, the OPC and ESR registers are included for legacy
purposes.
It is not recommended to include an error register query command with any other
commands in a set of commands; any syntax error in those other commands may cause the
error register query command to not be actioned.
These commands should be used following commands during testing of your software; they
may be removed later if desired. For the LAN interface it is highly unlikely that a command
will be corrupted, so the regular use of this type of error checking is not necessary; however
for the USB and RS232 interfaces it is possible for commands to become corrupted during
transmission to the M2000 so the use of the *ERR? command is recommended in high
interference environments.
The ERR register is automatically cleared when an interface is disconnected or when a LAN
interface socket is closed.
Non-zero contents of the ERR register cause the screen of the M2000 to indicate an error
message in the Error Info Area. This message remains until the ERR register is cleared.
COMMAND
KEYWORD
FIELD(s) FIELD
FORMAT
FIELD DATA
RANGE
DESCRIPTION
*ERR? - - - Responds with the NR1 ERR register contents and clears the
register
Response is the highest error encountered since cleared and has
the following possible values -
0: No error has occurred
1: The command cannot not be executed at this time
2: The content or configuration of the M2000 was not compatible
with a command
3: An interface command field was syntactically valid but the data
was out of the valid range
4: An interface command field was syntactically invalid
5: An interface command field was expected but not found
6: An interface command field was found but not expected
M2000 SERIES OPERATION MANUAL
SECTION 10: REMOTE CONTROL
Entire Contents Copyright 2019
M2000 Series Power Analyzers Operation Manual Page 250 of 284
COMMAND
KEYWORD
FIELD(s) FIELD
FORMAT
FIELD DATA
RANGE
DESCRIPTION
7: An invalid interface command was found
8: The requested response data contains too many characters
9: A response was requested but the previous response has not
been read
10: A Rx overrun occurred
*ESR? - - - Responds with the NR1 ESR register contents and clears the
register.
The response forms a single byte quantity with the following
logical bit meanings (b0 is the LS bit) for other than the GPIB
interface -
b0: Set if an interface command error occurred
b1: Set if a Tx overrun occurred
This register has a different format for the GPIB interface as
followsb0:
Set by the *OPC command (which is only available in the GPIB
interface)
b3: A query error has occurred
b4: a command execution error occurred
b5: a command error occurred
b7: set if a power on has occurred (for the M2000 this is
extended to also be set when the GPIB interface is changed from
disabled to enabled)
*OPC? - - - Responds with the NR1 OPC register contents and clears the
register
The response forms a single byte quantity with the following
logical bit meanings (b0 is the LS bit) for other than the GPIB
interface -
b0: Set if an interface command error did not occur
b1: Set if an interface command had too many or too few fields
b2: Set if an interface command field syntax or data range error
occurred
b3: Set if an interface command field was not compatible with
the content or configuration
b4: Set if a Tx overrun occurred
b5: Set if a Rx overrun occurred
b6: Set if an unknown command was received
The response to this command has a different format for the
GPIB interface as follows-
The response is always a NR1 having value 1
10.5.5 Date and Time Control and Query Commands
COMMAND
KEYWORD
FIELD(s) FIELD
FORMAT
FIELD DATA
RANGE
DESCRIPTION
DATE d NR1 1 to 31 Sets the date (d), month (m) and year (y)
m NR1 1 to 12
Y NR1 0 to 99
DATEFMT f NR1 0 or 1 Sets MDY (f=0) or DMY (f=1) displayed date format
DATE? - - - Responds with the STRING format present date (as selected
format). E.g. DD/MM/YYYY
TIME h NR1 0 to 23 Sets the hour (h, 24 hour format), minute (m) and second (s). The
s field m NR1 0 to 59 is optional.
s NR1 0 to 59
TIMEFMT f NR1 0 or 1 Sets 24 hour (f=0) or 12 hour (f=1) displayed time format
TIME? - - - Responds with the STRING format present time (as selected
format). E.g. HH:MM:SSam
M2000 SERIES OPERATION MANUAL
SECTION 10: REMOTE CONTROL
Entire Contents Copyright 2019
M2000 Series Power Analyzers Operation Manual Page 251 of 284
10.5.6 System Preferences Set and Query Commands
COMMAND
KEYWORD
FIELD(s) FIELD
FORMAT
FIELD DATA
RANGE
DESCRIPTION
AUTOZERO s NR1 0 or 1 Sets that environmental tracking of DC zeroes is enabled (s=1) or
disabled (s=0)
AUTOZERO? - - - Responds with the NR1 DC zero environment tracking setting
0: Environment tracking is disabled 1: Environment tracking is
enabled
FREQSPEED s NR1 0 to 2 Sets that the response speed to frequency changes is fast (s=0),
normal (s=1) or slow (s=2)
FREQSPEED? - - - Responds with the NR1 frequency change response speed is fast
(0), normal (1) or slow (2)
PHASEPREF s NR1 0 to 7 Sets the PHASE preference setting according to the NR1 value of s
as follows (see 12.3.1.6 for full details)-
0: Math, -180 to +180° range, CW = increasing phase on the
vectors chart
1: Math, -180 to +180° range, CCW = increasing phase on the
vectors chart
2: Math, 0 to 360° range, CW = increasing phase on the vectors
chart
3: Math, 0 to 360° range, CCW = increasing phase on the vectors
chart
4: Delay, -180 to +180° range, CW = increasing phase on the
vectors chart
5: Delay, -180 to +180° range, CCW = increasing phase on the
vectors chart
6: Delay, 0 to 360° range, CW = increasing phase on the vectors
chart
7: Delay, 0 to 360° range, CCW = increasing phase on the vectors
chart
PHASEPREF? - - - Responds with the NR1 value of the PHASEPREF setting as
described above.
SUMVA s NR1 0 or 1 Sets the VA/VAR total method as VAR is summed, VA is calculated
(s=0) or VA is summed, VAR is calculated (s=1).
SUMVA? - - - Responds with the NR1 VA/VAR total method as VAR is summed
and VA is calculated (0) or VA is summed and VAR is calculated
(1).
VARPOL s NR1 0 or 1 Sets the VAR polarity as VAR is positive (s=0) or negative (s=1) for
leading PF
VARPOL? - - - Responds with the NR1 VAR polarity setting as VAR is positive (0)
or negative (1) for leading PF
10.5.7 Measurement State Control and Query Commands
COMMAND
KEYWORD
FIELD(s) FIELD
FORMAT
FIELD DATA
RANGE
DESCRIPTION
CLRINRUSH - - - Clears all inrush (max. hold) measurement results
Inrush results are invalid until the next measurement period
completion
DATALOG s NR1 0 or 1 Sets whether data logging is to be started (s=1) or stopped (s=0)
DATALOG? - - - Responds with two fields indicating the present state of data
logging
1st field (NR1) -
0: no data logging activity is presently being performed
1: performing data logging
2nd field (NR1)
This field is maintained after a data log is terminated and is
cleared to 0 when a data log is started.
0: There has been no data logging error
M2000 SERIES OPERATION MANUAL
SECTION 10: REMOTE CONTROL
Entire Contents Copyright 2019
M2000 Series Power Analyzers Operation Manual Page 252 of 284
COMMAND
KEYWORD
FIELD(s) FIELD
FORMAT
FIELD DATA
RANGE
DESCRIPTION
1: Data logging was terminated because of file size limitation
(approx. 4Gbytes)
2: Data logging was terminated because the drive became full
3: Data logging was terminated because of a drive write error
4: Data logging has terminated because the drive was removed
HISTORY s NR1 0 or 1 Stops (s=0) or (re)starts (s=1) historical data collection, data is
cleared on (re)starting
HISTORY? - - - Responds with NR1 whether historical data collection is being
performed (1) or not (0)
HOLD s NR1 0 or 1 Sets whether measurements are held (s=1) or not (s=0)
HOLD? - - - Responds with NR1 whether measurements are held (1) or not
(0)
INTEG s NR1 0 or 1 Stops (s=0) or (re)starts (s=1) integrated data collection, data is
cleared and the configured delay is initiated on (re)starting as
applicable
INTEG? - - - Responds with NR1 indicating the present state of integration
0: integrated results are not being updated
1: integrated results are going to be updated after the configured
delay has expired
2: integrated results are held because of measurement hold
3: integrated results are being updated
MCR? - - - Responds with the NR1 MCR (Measurement Completion Register)
and clears it
The NR1 is a 32- -
bits (b0 is the LS bit) -
b0 through 2: set if VPA 1 through 3 resp. have completed a nonharmonic
measurement
b3: set if motor measurements have been completed
b8 through 10: set if VPA 1 through 3 resp. have completed a
harmonic measurement
b16: set if spectrum measurements have been completed
Note: this register is also cleared when any measurement
configuration change is made with the SAVECONFIG command.
SCOPE s NR1 0 to 2 Stops (s=0), starts a single (s=1) or starts a continuous (s=2) scope
view capture
If starting (s =1 or s =2) then any previously captured scope view
data is cleared.
SCOPE? - - - Returns the present status of scope view capture as a NR1 as
follows
0: Scope view capture is stopped (no data has been collected)
1: Scope view capture is stopped (data has been collected)
2: A single scope view capture is in progress (no data has been
collected)
3: Continuous scope view capture is in progress (no data has
been collected)
4: Continuous scope view capture is in progress (data has been
collected)
STBYRUN v VDEF - Stops (s=0) or starts (s=1) a standby power measurement in VPA v
s NR1 0 or 1 Stops (s=0) or starts (s=1) a standby power measurement in VPA v
STBYSTATE? v VDEF - Returns the present state of standby power measurement in VPA
v as a NR1 as follows-
0: No standby measurement in progress and no data is available
(none has been previously run)
1: The last standby measurement was stopped by the operator
and data is available
2: The last standby measurement was stopped normally and data
is available
3: A EN50564 5.3.2d measurement is in progress but is waiting
for the start detection level (no data is available).
M2000 SERIES OPERATION MANUAL
SECTION 10: REMOTE CONTROL
Entire Contents Copyright 2019
M2000 Series Power Analyzers Operation Manual Page 253 of 284
COMMAND
KEYWORD
FIELD(s) FIELD
FORMAT
FIELD DATA
RANGE
DESCRIPTION
4: A EN50564 5.3.2a measurement is in progress and is within the
specified minimum time period (data is available).
5: A EN50564 5.3.2a measurement is in progress and has been
extended beyond the specified minimum time period (data is
available).
6: A EN50564 5.3.2d measurement is in progress (data is
available).
10.5.8 Configuration Store and Recall Commands
The M2000 contains 10 internal configuration storage areas into which you may save all
configuration settings other than the power preference setting, the interface configuration
and the time and date format configuration settings.
There is also a FACTORY configuration storage allowing you to set the configuration settings
to the factory defaults (this storage cannot be overwritten).
COMMAND
KEYWORD
FIELD(s) FIELD
FORMAT
FIELD DATA
RANGE
DESCRIPTION
*SAV n NR1 1 to 10 Saves the present configuration into store n.
*RCL n NR1 0 to 10 Recalls the configuration from either
n = 0: Factory settings
n = 1 to 10: store n (must have been previously saved into)
10.5.9 Measurement Configuration Edit Commands
The Measurement Configuration Edit commands shown below have been split into separate
sections for clarity. All of the commands described in these sections are controlled by the
EDITCONFIG and SAVECONFIG commands.
While performing an internal DC zero you should not send any of these commands to the
M2000.
These commands are checked only for syntax and compatibility with the installed hardware
(if applicable) when each command is received and are not executed and the consistency of
setting combinations are not checked until the SAVECONFIG command is used. In this
manner you may configure measurements using these commands in any order without the
need to consider intermediate potentially incompatible setting combinations. For this
reason, the CH1 to CH4 variants of the VDEF field format are not allowed for these
commands.
If you are unsure if there are any pending commands from these sections (e.g. from a prior
session where the SAVECONFIG command was not used) then you may use the EDITCONFIG
command to ensure that there are none (the *RST or *CLS command also accomplish this
and are the recommended method but also perform other functions).
A typical command flow is:
1. Send the EDITCONFIG command (only to ensure there are no previously unsaved
measurement configuration changes)
2. Send the required measurement configuration commands (in any order)
M2000 SERIES OPERATION MANUAL
SECTION 10: REMOTE CONTROL
Entire Contents Copyright 2019
M2000 Series Power Analyzers Operation Manual Page 254 of 284
3. Send the SAVECONFIG command (to execute the prior measurement configuration
commands)
The above command flow can be sent in any number of sets of commands, including all in
the same set of commands.
COMMAND
KEYWORD
FIELD(s) FIELD
FORMAT
FIELD DATA
RANGE
DESCRIPTION
EDITCONFIG - - - Sets the configuration to be edited by the interface to that
presently being used in the M2000.
SAVECONFIG - - - Sets the presently used configuration within the M2000 to include
all changes made via the interface since the prior EDITCONFIG or
SAVECONFIG command. When this command is executed all
measurements in progress may be abandoned and restarted with
the changed configuration (depending on the changes made)
Measurement Mode Configuration Command
COMMAND
KEYWORD
FIELD(s) FIELD
FORMAT
FIELD DATA
RANGE
DESCRIPTION
MODE m NR1 0 to 3, or 5
or 7
Sets the overall operating mode for the M2000:
m=0: Single VPA mode
m=1: Multi-VPA mode (only valid if more than one channel fitted)
m=2: Sync-VPA mode (only valid if more than one channel fitted)
m=3: EN61000-3-2 mode
m=5: EN61000-3-12 mode
m=7: SPECTRUM mode
Channel Configuration Commands
COMMAND
KEYWORD
FIELD(s) FIELD
FORMAT
FIELD DATA RANGE DESCRIPTION
ARANGE c CDEF - Sets the current input range for channel c:
r=0: Selects the HI range
r=1: selects the LO range
r=2: selects for auto-range (only valid for a D current
input channel)
r NR1 H input : 0 only
D input : 0 to 2
X input : 0 to 1
ASCALE c CDEF - Sets the current scaling and offset for channel c
If s=zero then turns off scaling and offset (o is ignored),
otherwise turns on scaling and offset using s and o
respectively
Field o is optional, zero is used if not present
s NR3 0.0, or +1e-6 to +1e6
o NR3 Within the measurable
range of the channel
current option
VSCALE c CDEF - Sets voltage scaling for channel c
If s=zero then turns off scaling
Otherwise turns on voltage scaling using s
s NR3 0.0, or +1e-3 to +1e6
M2000 SERIES OPERATION MANUAL
SECTION 10: REMOTE CONTROL
Entire Contents Copyright 2019
M2000 Series Power Analyzers Operation Manual Page 255 of 284
VPA Configuration Commands
COMMAND
KEYWORD
FIELD(s) FIELD
FORMAT
FIELD DATA
RANGE
DESCRIPTION
ADJUST v VDEF - Sets that signals in VPA v may be adjusted for the voltage drop
across the A terminals, or the current in the V terminals
a=0: No adjustments are made
a=1: adjusts the A signal to compensate for the V input current
when V is connected at the source and you require the results at
the source (the V current is added to the A signal)
a=2: adjusts the V signal to compensate for the A input drop
when V is connected at the load and you require the results at
the source (the A drop is added to the V signal)
a=3: adjusts the V signal to compensate for the A input drop
when V is connected at the source and you require the results at
the load (the A drop is subtracted from the V signal)
a=4: adjusts the A signal to compensate for the V input current
when V is connected at the load and you require the results at
the load (the V current is subtracted from the A signal)
a NR1 0 to 4
BANDWIDTH v VDEF - Sets the Bandwidth Limit for VPA v
h=0: Auto-Track Bandwidth Limiting
h=1: No Bandwidth Limiting
h=2: Fixed frequency bandwidth limiting set by the freq field in Hz
The freq field is optional and is ignored if present if h is not 2.
h NR1 0 to 2
freq NR3 >0.0
CHANNELS v VDEF - Sets the channels included in VPA v to c = additive channel
selection, CH1=1, c NR1 0 to 15 CH2=2, CH3=4, CH4=8
COUPLE v VDEF - Sets the default measurement result coupling for VPA v to AC+DC
C NR1 0 to 2 (c=0), AC (c=1) or DC (c=2)
DIGITS v VDEF - Sets the number of displayed digits for VPA v results to d
D NR1 3 to 6
EFFGROUP v VDEF - Sets the efficiency group for VPA v to None (e=0), IN (e=1),
e NR1 0 to 3 MIDDLE (e=2) or OUT (e=3)
FUND v VDEF - Sets the fundamental frequency for VPA v
f=0: No fundamental (freq ignored)
f=1: Fixed fundamental (freq sets the frequency)
f=2: V input measurement (freq sets the maximum allowed
frequency)
f=3: A input measurement (freq sets the maximum allowed
frequency)
f=4: MAINS fundamental (freq ignored)
f=5: AVIONICS fundamental (freq ignored)
f=6 through 8: Use VPA1 through 3 resp. as the fundamental
frequency (freq ignored) cannot use VPA v
f=9 through 11: Use GFUND1 through 3 resp. as the fundamental
frequency (freq ignored)
The freq field need not be present if not needed
f NR1 0 to 11
freq NR3 Set by
PERIOD
command
selection
HARMS v VDEF - Sets the maximum number of harmonics for VPA v to h
h NR1 0 to 500
PERIOD v VDEF - Sets the measurement period for VPA v
p=0: VLF p=1: LF
p=2: 10Hz/0.3s
p=3: 20Hz/0.1s
p=4: 45Hz/20ms
p=5: 150Hz/10ms
p=6: 500Hz/2ms (not valid unless the VPA contains W type
channels)
p=7: Full synchronization with VPA1 (not valid if v = VPA1)
p=8: Full synchronization with VPA2 (not valid if v = VPA1 or
VPA2)
p NR1 v = 1 : 0 to 6
v = 2 : 0 to 7
v = 3 : 0 to 8
M2000 SERIES OPERATION MANUAL
SECTION 10: REMOTE CONTROL
Entire Contents Copyright 2019
M2000 Series Power Analyzers Operation Manual Page 256 of 284
COMMAND
KEYWORD
FIELD(s) FIELD
FORMAT
FIELD DATA
RANGE
DESCRIPTION
RESPONSE v VDEF - Sets the measurement response for VPA v to Fastest (r=0),
Medium (r=1), Slow (r=r NR1 0 to 3 2) or Slowest (r=3)
STBYA v VDEF - Sets VPA v for EN50564 5.3.2 method A standby power
measurements
d is the minimum number of days for the measurement.
h is the minimum number of hours for the measurement.
m is the minimum number of minutes for the measurement.
s is the minimum number of seconds for the measurement.
d NR1 0 to 99
h NR1 0 to 99
m NR1 0 to 99
s NR1 0 to 99
STBYD v VDEF - Sets VPA v for EN50564 5.3.2 method D standby power
measurements
s is the starting power detection level.
e is the ending power detection level.
s NR3
e NR3
WIRING v VDEF - Sets the wiring method for VPA v:
w=0: N x 1ø method.
w=1: 2ø3w method.
w=2: 3ø3w (2 channel) method.
w=3: 3ø3w (3 channel) method.
w=4: 3ø4w method
w NR1 0 to 4
Scope View Configuration Commands
COMMAND
KEYWORD
FIELD(s) FIELD
FORMAT
FIELD DATA
RANGE
DESCRIPTION
SCOPEINRUSH e NR1 0 or 1 Sets if performing a scope capture will temporarily override the A
RANGE setting to HI and the BANDWIDTH setting to UNFILTERED
(e=1) or not (e=0).
TIMEBASE b NR1 0 to 20 b b=1),
b b b b b=6),
1ms (b=7), 2ms (b=8), 5ms (b=9), 10ms (b=10), 20ms (b=11),
50ms (b=12), 100ms (b=13), 200ms (b=14), 500ms (b=15), 1s
(b=16), 2s (b=17), 5s (b=18), 10s (b=19) or 20s (b=20)
TRIGGER i NR1 0 to 7 Configures scope data capture triggering
Trigger Input (i) :
i=0: Trigger using CH 1 V input signal
i=1: Trigger using CH 1 A input signal
i=2: Trigger using CH 2 V input signal
i=3: Trigger using CH 2 A input signal
i=4: Trigger using CH 3 V input signal
i=5: Trigger using CH 3 A input signal
i=6: Trigger using CH 4 V input signal
i=7: Trigger using CH 4 A input signal
Trigger Detection Method (t) :
t=0: DC rising edge
t=1: DC falling edge
t=2: Rectified signal (rising edge)
t=3: High Frequency
Trigger Position (p) :
p=0: Trigger is at 0% of the captured time span
p=1: Trigger is at 25% of the captured time span
p=2: Trigger is at 50% of the captured time span
p=3: Trigger is at 75% of the captured time span
Trigger Level (l) in V or A units as applicable
Integration Configuration Commands
COMMAND
KEYWORD
FIELD(s) FIELD
FORMAT
FIELD DATA
RANGE
DESCRIPTION
INTEGAUTO i NR1 0 or 1 Sets that integration will be automatically timed (i=1) or manually
stopped and started (i=0)
M2000 SERIES OPERATION MANUAL
SECTION 10: REMOTE CONTROL
Entire Contents Copyright 2019
M2000 Series Power Analyzers Operation Manual Page 257 of 284
COMMAND
KEYWORD
FIELD(s) FIELD
FORMAT
FIELD DATA
RANGE
DESCRIPTION
INTEGDELAY d NR1 0 to 99 Sets the automatically timed integration start delay time to d
days, h hours, m minutes h NR1 0 to 99 plus s seconds.
m NR1 0 to 99
s NR1 0 to 99
INTEGRUN d NR1 0 to 99 Sets the automatically timed integration run time to d days, h
h NR1 0 to 99 hours, m minutes plus s seconds.
m NR1 0 to 99
s NR1 0 to 99
Data Logging Configuration Commands
COMMAND
KEYWORD
FIELD(s) FIELD
FORMAT
FIELD DATA
RANGE
DESCRIPTION
LOGDATA t NR1 0 or 1 Sets the data to be saved in each data logging record
Each record includes a time/date field (t=1) or not (t=0) and data
for each DDEF field (in order)
0 to 16
fields
DDEF
LOGDELAY d NR1 0 to 99 Sets the data logging start delay time to d days, h hours, m
h NR1 0 to 99 minutes plus s seconds
m NR1 0 to 99
s NR1 0 to 99
LOGFILE f NR1 0 or 1 Configures the file used for data logging
File Format:
f=0: ASCII
f=1: Binary
f=2: Internal (no further fields should be present)
h=0: No header (not valid for binary format)
h=1: Header included
File append:
a=0: File (if exists) will be overwritten
a=1: File (if exists) will be appended
File Name (name) (excluding extension, first eight characters
only) this is case insensitive and may only contain valid file
name characters for the 8.3 filename format (long file names are
not supported).
h NR1 0 or 1
a NR1 0 or 1
name STRING 1 to 8
characters
LOGINTERVAL h NR1 0 to 99 Sets the data logging interval time to h hours, m minutes, s
seconds plus f 1/100th seconds (if all fields are zero then 0.002s is
used)
m NR1 0 to 99
s NR1 0 to 99
f NR1 0 to 99
LOGRUN d NR1 0 to 99 Sets the data logging run time to d days, h hours, m minutes plus
h NR1 0 to 99 s seconds (if all fields are 0 then selects manually timed)
m NR1 0 to 99
s NR1 0 to 99
M2000 SERIES OPERATION MANUAL
SECTION 10: REMOTE CONTROL
Entire Contents Copyright 2019
M2000 Series Power Analyzers Operation Manual Page 258 of 284
Measurement Configuration Commands
Notes: These commands respond with the requested configuration being used at the time
of the command, not including any unsaved changes.
Commands with a VDEF field will raise an error if the VDEF field defines a VPA that is
not available.
Commands with a CDEF field will raise an error if the CDEF field defines a that which
is not installed.
COMMAND
KEYWORD
FIELD(s) FIELD
FORMAT
FIELD DATA
RANGE
DESCRIPTION
ADJUST? v VDEF - Responds with the NR1 adjustment setting for VPA v:
0: No adjustments are made
1: adjusts the A signal to compensate for the V input current
when V is connected at the source and you require the results
at the source (the V current is added to the A signal)
2: adjusts the V signal to compensate for the A input drop when
V is connected at the load and you require the results at the
source (the A drop is added to the V signal)
3: adjusts the V signal to compensate for the A input drop when
V is connected at the source and you require the results at the
load (the A drop is subtracted from the V signal)
4: adjusts the A signal to compensate for the V input current
when V is connected at the load and you require the results at
the load (the V current is subtracted from the A signal)
ARANGE? c CDEF - Responds with the NR1 current input range setting for channel
c:
0: Set for the HI range
1: Set for the LO range
2: Set for auto-range, using the HI range
3: Set for auto-range, using the LO range
ASCALE? c CDEF - Responds with the current scaling and offset settings for
channel c in two fields:
1st NR3 : current scaling setting (0.0 if not configured for scaling
and offset)
2nd NR3 : current offset setting (0.0 if not configured for scaling
and offset)
BANDWIDTH? v VDEF - Responds with the NR1 Bandwidth Limit setting for VPA v:
0: Auto-Track Bandwidth Limit
1: No bandwidth limit
2: Fixed frequency bandwidth limit, this is followed by a NR3
field containing the bandwidth limit frequency in Hz.
CHANNELS? v VDEF - Responds with the NR1 channel inclusion setting for VPA v:
0: none
1 through 15: additive channel selection, CH1=1, CH2=2, CH3=4,
CH4=8
COUPLE? v VDEF - Responds with the NR1 default measurement result coupling
setting for VPA v:
0: AC+DC
1: AC Only
2: DC Only
DIGITS? v VDEF - Responds with the NR1 displayed digits setting for VPA v
DIR? - - - Responds with the NR1 DIR input polarity setting (DIR
command)
EFFGROUP? v VDEF - Responds with the NR1 efficiency group setting for VPA v:
0: None
1: IN
2: MIDDLE
M2000 SERIES OPERATION MANUAL
SECTION 10: REMOTE CONTROL
Entire Contents Copyright 2019
M2000 Series Power Analyzers Operation Manual Page 259 of 284
COMMAND
KEYWORD
FIELD(s) FIELD
FORMAT
FIELD DATA
RANGE
DESCRIPTION
3: OUT
FUND? v VDEF - Responds with the fundamental frequency setting for VPA v as
two fields, the 1st field is a NR1 and the 2nd is a NR3 - NR1 value:
0: No fundamental, NR3 is 0.0
1: Fixed fundamental, NR3 is the fixed value
2: V input measurement, NR3 is the maximum limit
3: A input measurement, NR3 is the maximum limit
4: MAINS, NR3 is 0.0
5: AVIONICS, NR3 is 0.0
6 through 8: Use VPA1 through 3 resp. as the fundamental
frequency, NR3 is 0.0
9 through 11: Use GFUND1 through 3 resp. as the fundamental
frequency, NR3 is 0.0
HARMS? v VDEF - Responds with the NR1 maximum number of harmonics setting
for VPA v
INTEGAUTO? - - - Responds with a NR1 if integration is automatically controlled
(1) or manually controlled (0)
INTEGDELAY? - - - Responds with four NR1 values for the automatically controlled
integration delay time (days, hours, minutes and seconds
respectively).
INTEGRUN? - - - Responds with four NR1 values for the automatically controlled
integration run time (days, hours, minutes and seconds
respectively).
LOGDATA? - - - Responds with the presently defined data content in each data
logging record
1st field (NR1) indicates if time and date is included (1) or not (0)
2nd through 17th fields (STRING) indicate the definition for each
data field in the record (a blank field in the response indicates
that the field is not included in the record)
LOGDELAY? - - - Responds with the present delay time for data logging as four
NR1 fields indicating the days, hours, minutes and seconds
respectively.
LOGFILE? - - - Responds with the present file settings for data logging:
1st field (NR1) indicates if the file is in binary (1) or ASCII (0)
format or saved to internal memory (2)
2nd field (NR1) indicates if a header record will be included (1) or
not (0)
3rd field (NR1) indicates if an existing file will be append to (1) or
overwritten (0)
4th field (STRING) is the file name (including extension)
LOGINTERVAL? - - - Responds with the present interval for data logging as four NR1
fields indicating the hours, minutes, seconds and 0.01seconds
respectively.
LOGRUN? - - - Responds with the present run time for data logging as four NR1
fields indicating the days, hours, minutes and seconds
respectively (manually controlled if all fields are 0)
MODE? - - - Responds with a NR1 showing the present overall operating
mode for the M2000.
0: Single VPA mode
1: Multi-VPA mode
2: Sync-VPA mode
3: EN61000-3-2 mode
5: EN61000-3-12 mode
7: SPECTRUM mode
MTRDIGITS? - - - Responds with NR1 number of displayed digits for motor
measurement results.
MTREFFGROUP
?
- - - Responds with the NR1 efficiency group setting for motor
power:
0: None
M2000 SERIES OPERATION MANUAL
SECTION 10: REMOTE CONTROL
Entire Contents Copyright 2019
M2000 Series Power Analyzers Operation Manual Page 260 of 284
COMMAND
KEYWORD
FIELD(s) FIELD
FORMAT
FIELD DATA
RANGE
DESCRIPTION
1: IN
2: MIDDLE
3: OUT
MTRPERIOD? - - - Responds with the Nr1 measurement period for motor
measurements:
0: 10ms measurement period
1: 30ms measurement period
2: 100ms measurement period
3: 300ms measurement period
4: 1s measurement period
5: 3s measurement period
6: 10s measurement period
7: 30s measurement period
8: 100s measurement period
9: Measurement period synchronous with VPA1
10: Measurement period synchronous with VPA2
11: Measurement period synchronous with VPA3
MTRPOLES? - - - Responds with the NR3 setting for the number of motor poles
(set with the MTRPOLES command)
MTRSLIP? - - - Responds with the NR1 selection controlling the calculation of
motor slip:
0: no motor slip calculation
1: motor slip uses the frequency from VPA1 as the drive
frequency
2: motor slip uses the frequency from VPA2 as the drive
frequency
3: motor slip uses the frequency from VPA3 as the drive
frequency
PERIOD? v VDEF - Responds with the NR1 measurement period setting for VPA v:
0: VLF
1: LF
2: 10Hz/0.3s
3: 20Hz/0.1s
4: 45Hz/20ms
5: 150Hz/10ms
6: 500Hz/2ms
7: Full synchronization with VPA1
8: Full synchronization with VPA2
RESPONSE? v VDEF - Responds with the NR1 measurement response setting for VPA
v:
0: Fastest
1: Medium
2: Slow
3: Slowest
SCOPEINRUSH? - - - Responds with a NR1:
0: BANDWIDTH and A RANGE will not be overridden during a
scope data capture.
1: BANDWIDTH and A RANGE will be overridden during a scope
data capture.
SPD? - - - Responds with the NR1 indicating the configured SPD input-
0: No speed measurement
1: Speed measured using an analog input on the SPD connector
2: Speed measured using a digital input on the SPD connector
3: Speed measured using a digital input on the SPD connector
with direction indicated by the digital input on the DIR
connector
4: Speed derived from the electrical drive frequency measured
in VPA1 (only valid if VPA1 configured for use)
5: Speed derived from the electrical drive frequency measured
in VPA2 (only valid if VPA2 configured for use)
M2000 SERIES OPERATION MANUAL
SECTION 10: REMOTE CONTROL
Entire Contents Copyright 2019
M2000 Series Power Analyzers Operation Manual Page 261 of 284
COMMAND
KEYWORD
FIELD(s) FIELD
FORMAT
FIELD DATA
RANGE
DESCRIPTION
6: Speed derived from the electrical drive frequency measured
in VPA3 (only valid if VPA3 configured for use)
SPDOFFSET? - - - Responds with the NR3 setting for the speed measurement
offset
SPDRISING? - - - Responds with NR1 indicating if the rising edge (1) or the falling
edge of the SPD digital input is being detected
SPDSCALE? - - - Responds with the NR3 setting for the speed measurement
scaling
STBY? v VDEF - Responds with the standby power measurement settings for
VPA v:
If the configured method is EN50564 5.3.2a:
1st field is a STRING of value A
2nd field is a NR1 with the days minimum measurement time
setting
3rd field is a NR1 with the days minimum measurement time
setting
4th field is a NR1 with the days minimum measurement time
setting
5th field is a NR1 with the days minimum measurement time
setting
If the configured method is EN50564 5.3.2d:
1st field is a STRING of value D
2nd field is a NR3 with the starting power detection level setting
3rd field is a NR3 with the ending power detection level setting
TIMEBASE? - - - Responds with the NR1 scope data capture time base setting as
(6), 1ms (7), 2ms (8), 5ms (9), 10ms (10), 20ms (11), 50ms (12),
100ms (13), 200ms (14), 500ms (15), 1s (16), 2s (17), 5s (18), 10s
(19) or 20s (20)
TRIGGER? - - - Responds with the scope data capture triggers settings as the
following four fields:
1st field (NR1) is the trigger input selection -
0: Trigger using CH 1 V input signal
1: Trigger using CH 1 A input signal
2: Trigger using CH 2 V input signal
3: Trigger using CH 2 A input signal
4: Trigger using CH 3 V input signal
5: Trigger using CH 3 A input signal
6: Trigger using CH 4 V input signal
7: Trigger using CH 4 A input signal
2nd field (NR1) is the trigger method selection:
0: DC rising edge
1: DC falling edge
2: Rectified signal (rising edge)
3: High Frequency
3rd field (NR1) is the trigger position selection:
0: trigger is at 0% of the captured time span
1: trigger is at 25% of the captured time span
2: trigger is at 50% of the captured time span
3: trigger is at 75% of the captured time span
4th field (NR3) is the configured trigger level in V or A units as
applicable
TRQ? - - - Responds with the NR1 indicating the configured TRQ input-
0: No torque measurement
1: Torque measured using an analog input on the TRQ
connector
2: Torque measured using a digital input on the TRQ connector
TRQOFFSET? - - - Responds with the NR3 setting for the torque measurement
offset
M2000 SERIES OPERATION MANUAL
SECTION 10: REMOTE CONTROL
Entire Contents Copyright 2019
M2000 Series Power Analyzers Operation Manual Page 262 of 284
COMMAND
KEYWORD
FIELD(s) FIELD
FORMAT
FIELD DATA
RANGE
DESCRIPTION
TRQSCALE? - - - Responds with the NR3 setting for the torque measurement
scaling
VSCALE? c CDEF - Responds with the NR3 voltage scaling setting (0.0 if not
configured for scaling) for channel c
VPA? c CDEF - Responds with the NR1 indicating which VPA channel c is
configured in (1 through 3) or if not configured or not installed
(0)
WIRING? v VDEF - Responds with the NR1 wiring method setting for VPA v
0: N x 1ø method.
1: 2ø3w method.
2: 3ø3w (2 channel) method.
3: 3ø3w (3 channel) method.
4: 3ø4w method
Configuration Temporary Save and Load Commands
These commands allow the user to temporarily save and reload the complete configuration
of the M2000 (the saved configuration is volatile, i.e. it is not retained after a power cycle).
COMMAND
KEYWORD
FIELD(s) FIELD
FORMAT
FIELD DATA
RANGE
DESCRIPTION
TEMPSAVECFG - - - Saves the present complete configuration of the M2000 into an
internal temporary storage.
TEMPLOADCFG - - - Reloads the previously saved configuration from a
TEMPSAVECFG command. If there was no previous
TEMPSAVECFG command then this command raises an error.
This command can only be used once for each TEMPSAVECFG
command.
Harmonic Limits Configuration and Query Commands
Any changes made to harmonics limits take an immediate effect but are volatile until the
SAVEHLIMITS command is used (i.e. will not be retained when power is turned off).
COMMAND
KEYWORD
FIELD(s) FIELD
FORMAT
FIELD DATA
RANGE
DESCRIPTION
CLRHLIMITS i KEYWORD V or A Removes all voltage (i=V) or current (i=A) harmonic limits
HLIMIT i KEYWORD V or A Sets voltage (i=V) or current (i=A) limit for harmonic h according
to the remaining fields as follows:
t sets the type of limit (if any) to apply:
t=0: no limit applied (further fields are optional and are ignored
if present)
t=1: the limit is the highest of the percentage and level limits
t=2: the limit is the addition of the percentage and level limits
p sets whether the percentage limit is a percentage of the
fundamental (p=0) or of the total signal (p=1)
plimit and llimit are the percentage and level limits respectively
Note : setting a limit with both plimit and llimit =0.0 will never
pass
h NR1 1 to 500
t NR1 0 to 2
p NR1 0 or 1
plimit NR3
llimit NR3
h NR1 1 to 500
HLIMIT? i KEYWORD V or A Responds with the HLIMIT command STRING needed to
reproduce the voltage (i=V) or current (i=A) limit h NR1 1 to 500 for harmonic h
SAVEHLIMITS i KEYWORD V or A Saves all voltage (i=V) or current (i=A) harmonic limits
M2000 SERIES OPERATION MANUAL
SECTION 10: REMOTE CONTROL
Entire Contents Copyright 2019
M2000 Series Power Analyzers Operation Manual Page 263 of 284
DC Zero Control and Query Commands
COMMAND
KEYWORD
FIELD(s) FIELD
FORMAT
FIELD DATA
RANGE
DESCRIPTION
DCZERO - - - Initiates an INT DC ZERO activity on all configured channels
(same as the SYS CONFIG -> INT DC ZERO button)
Sets DCZ register as needed and clears DCZERR register
Suspends normal measurement actions of the M2000 until
ENDDCZERO is received
DCZ? - - - Responds with the NR1 DCZ register:
b0 through 3: set if CH 1 through 4 resp. are performing an INT
DC Zero activity
Each bit clears when the activity is successfully completed or
ENDDCZERO commanded
DCZERR? - - - Responds with the NR1 DCZERR register:
b0 through 3: set if CH 1 through 4 resp. have found an error
during an INT DC Zero activity
ENDDCZERO - - - Terminates an INT DC ZERO activity on all channels (aborts if still
in progress)
Clears DCZ and DCZERR registers
Returns to normal measurement actions.
EXTDCZERO o NR1 0 or 1 Performs an external DC Zero. If o is 0 then all channels have
their DC zeroes adjusted to the present DC measurements,
otherwise if o is 1 then only those channels which are scaled
have their DC zeroes adjusted to the present DC measurements.
Custom Screen Configuration and Query Commands
The actual custom screen is not updated with the results of any changes until the
SAVECUSTOM command is actioned. The use of the CLRCUSTOM command is recommended
prior to starting to generate a custom screen via the interface to ensure that no existing
contents of a custom screen are included in a newly generated screen. Following a
SAVECUSTOM command no further custom screen commands can be executed for up to
300ms and attempting to do so raises an error.
Note that the CUSTOM command must either be the only command or the last command in
a set of commands (i.e. it must be terminated by a command terminator character).
A custom screen is composed of 57 cells arranged in 15 rows with row 0 (the topmost row)
only having a single column and rows 1 through 14 having 4 columns (the leftmost column is
0). For cells other than the row 0 cell, for text sizes other than 12pix or 16pix then the target
cell is expanded to include surrounding cells as follows:
22pix text size: includes the cell to the right of the target cell.
28pix and 36pix text sizes: includes the cell to the right of the target cell and also the
cells immediately below both the target cell and that to the right of it.
COMMAND
KEYWORD
FIELD(s) FIELD
FORMAT
FIELD DATA
RANGE
DESCRIPTION
CLRCUSTOM - - - Sets the custom screen totally blank
CUSTOM r NR1 0 to 14 Set custom screen cell row (r), column (c) according to the
remaining fields:
size sets the text size to 12pix (size=0), 16pix (size=1), 22pix
(size=2), 28pix (size=3) or 36pix (size=4)
just sets the horizontal text justification to left (just=0), centered
(just=1) or right (just=2)
color sets the text color (R:G:B values)
M2000 SERIES OPERATION MANUAL
SECTION 10: REMOTE CONTROL
Entire Contents Copyright 2019
M2000 Series Power Analyzers Operation Manual Page 264 of 284
COMMAND
KEYWORD
FIELD(s) FIELD
FORMAT
FIELD DATA
RANGE
DESCRIPTION
c NR1 0 to 3 def sets the measurement result to be shown (blank if none
required)
units selects whether to include the measurement results units
(units=1) or not (units=0)
text sets the text to include. If def is defined then up to the first
5 characters of text are included to the left of the measurement
result otherwise the cell contains up to the first 60 characters of
text; if no characters are to be included in the cell then the text
field need not be present
If both def and text fields are blank (or not included) then only
the r and c fields are used
size NR1 0 to 4
just NR1 0 to 2
color COLOR -
def RDEF -
units NR1 0 or 1
text STRING Up to 60
characters
CUSTOM? r NR1 0 to 14 Responds with the CUSTOM command string to recreate custom
screen row r and column c
SAVECUSTOM - - - Saves the present custom screen internally and makes any
changes active
Measurement Results Query Commands
These commands which have a VDEF field will raise an error if the VDEF field defines a VPA
which is not available. These commands which have a CDEF field will raise an error if the
CDEF field defines a channel which is not installed.
COMMAND
KEYWORD
FIELD(s) FIELD
FORMAT
FIELD DATA
RANGE
DESCRIPTION
CYCLEVIEW? c CDEF - Responds with the 512 data points of cycle view data for
channel c voltage (s=V), current (s=A) or power (s=W)
waveforms
The data points correspond to phases of the fundamental
starting at 0° and then at successive (360/512)° increments.
Each data point contains two fields as follows
1st field : NR1 indicating if this data point has a valid data (1) or
not (0)
2nd field : NR3 indicating the level at this data point
Note the response is a large number of characters
(approximately 7K) and is a total of 1024 fields. Not all data
points may be valid, interpolate between valid data points as
appropriate.
s KEYWORD V or A or W
HARMLIST? i KEYWORD V or A or W Responds with one NR3 harmonic amplitude for the voltage
input (i=V) or current input (i=A) or power (i=W) of channel c for
each harmonic starting with the start harmonic up to and
including the end harmonic (the fundamental is harmonic 1).
c CDEF -
start NR1 1 to 500
end NR1 start to 500
HISTORYDATA? n NR1 2 to 1024 Responds with n data points of historical data defined by def,
starting at historical data collection time start and ending at end
(both in seconds relative to the time at which historical data
collection was last started)
Each data point is four fields as follows
1st field: NR1 indicating if this data point contains data (1) or
not (0)
2nd field: NR3 indicating the maximum data recorded
3rd field: NR3 indicating the average data recorded
4th field: NR3 indicating the minimum data recorded
Note the response can be a very large number of characters
(up to 38.9K) and fields (up to 4096).
start NR3
end NR3 >start
def DDEF -
HISTORYTIME? - - - Responds with an NR3 indicating the length of time covered by
the present historical data (in seconds)
HLIMITFAIL? c CDEF - Responds with a NR1 indicating if harmonic h (h>0) or all
harmonics (h=0) for the voltage (i=V) or current (i=A) of channel
c is passing (responds with 0) or failing (responds with 1)
i KEYWORD V or A
h NR1 0 to 500
M2000 SERIES OPERATION MANUAL
SECTION 10: REMOTE CONTROL
Entire Contents Copyright 2019
M2000 Series Power Analyzers Operation Manual Page 265 of 284
COMMAND
KEYWORD
FIELD(s) FIELD
FORMAT
FIELD DATA
RANGE
DESCRIPTION
Note: A harmonic which has no limit or is not being measured is
considered as passing
LEADING? srce KEYWORD CH1, CH2,
CH3, CH4,
A1, A2, A3,
VPA1,
VPA2, or
VPA3
Responds with a NR1 indicating if the selected data source (srce)
has a leading PF (responds with 1) or lagging PF (responds with
0)
srce is either:
A1 to A3: selects VPA1 to 3 as the data source
VPA1 to VPA3: selects VPA1 to 3 as the data source
CH1 to CH4: selects channel 1 to channel 4 as the data source
MAXHARMS? v VDEF - Responds with a NR1 indicating the number of harmonics being
measured in VPA v
READ? RDEF - Responds with the requested measurement result(s). You may
specify any number of results to be obtained in a single READ?
Command, as long as the command is within the allowable
maximum number of characters in a command set and the
response generated is less than the maximum number of
characters in a response.
REREAD? - - - Responds with the measurement results defined by the last
received READ? command.
Note: This is typically used when a large number of results are
to be repeatedly requested and a slow interface (e.g. USB or
RS232) is being used. Sending the READ? command once and
then repeating by using the REREAD? command achieves higher
throughput because of the reduction in characters required.
When using the LAN interface, there is typically very little
difference if the REREAD? command is used vs using the READ?
Command.
SCOPEVIEW? c CDEF - Responds with n data points of scope view data defined by c
and s, starting at time start and ending at end (both in seconds
relative to the trigger detection time)
Each data point is three fields as follows
1st field: NR1 indicating if this data point contains data (1) or
not (0)
2nd field: NR3 indicating the minimum level at this data point
3rd field: NR3 indicating the maximum level at this data point
Note: The response can be a very large number of characters
(up to 55.3K) and fields (up to 6144).
Note: If the requested timespan is a small fraction of the
captured timespan then not all response data may have valid
data.
s KEYWORD V or A or W
n NR1 2 to 2048
start NR3 -
end NR3 >start
STBYERR? c CDEF - Responds with a NR1 indicating if the M2000 measurement
error was outside of the requirements of EN50564 at any time
during the measurement (responds with 1) or not (responds
with 0)
STBYHISTORY? c CDEF - Responds with n data points of standby historical data defined
by def, ending at relative time end (in seconds relative to the
time at which the standby measurement was started)
n NR1 2 to 1024
end NR3 >0.0
def STRING W, V, VCF,
VTHD,
FREQ, A,
ACF, PF or
ERR
STBYVCF? c CDEF - Responds with a NR1 indicating if the voltage crest factor was
outside of the requirements of EN50564 at any time during the
measurement (responds with 1) or not (responds with 0)
STBYVTHD? c CDEF - Responds with a NR1 indicating if the voltage distortion was
outside of the requirements of EN50564 at any time during the
measurement (responds with 1) or not (responds with 0)
M2000 SERIES OPERATION MANUAL
SECTION 10: REMOTE CONTROL
Entire Contents Copyright 2019
M2000 Series Power Analyzers Operation Manual Page 266 of 284
10.5.10 RDEF Measurement Definition Field Sub-Fields
This field consists of one to five sub-fields, each separated by the sub-field separator (colon
character). The sub-fields may be specified in any order and may optionally be omitted (a
default value being used as needed).
Sub-Field Sub-field
Format
Value Description
Measurement Data KEYWORD FREQ Responds with a signal frequency (in Hz)
PERIOD Responds with a signal period (in seconds)
INTEGTIME Responds with the integration time (in Hours)
VOLTS or V Responds with a voltage (in V)
VPH-PH Responds with an inter-phase voltage (in V). The
measurement source field must be CH1 through CH4
defining a channel which is configured in a VPA which is
configured for 3p3w(3ch) or 3p4w wiring.
AMPS or A Responds with a current (in A)
WATTS or W DEFAULT if no other Measurement Data sub-field found
Responds with a real power (in W)
LOSS Responds with a real power loss (in W)
EFFICIENCY or EFF Responds with a real power efficiency (in %)
VAR Responds with an imaginary power (in W)
VA Responds with an apparent power (in VA)
PF Responds with power factor
PHASE Responds with apparent phase (cos-1(PF), in degrees)
LOADZ or ZLOAD Responds with load impedance (in ohms)
SERIESR Responds with load series resistance (in ohms)
SERIESL Responds with load series inductance (in henries)
PARALLELR Responds with load parallel resistance (in ohms)
PARALLELC Responds with load parallel capacitance (in farads)
SPEED Responds with motor speed (in rpm)
SLIP Responds with motor slip (in %)
TORQUE Responds with motor torque (in Nm)
HP Responds with motor power (in HP, use WATTS or W for
motor power in watts)
STBYTIME Responds with elapsed standby power measurement time
(in hours)
STBYERR Responds with standby power measurement error (in W)
Measurement Source KEYWORD CH1, CH2, CH3 or
CH4
CH1 is DEFAULT if no other Measurement Source sub-field
found Data is from the selected channel
A1, A2, A3, VPA1,
VPA2 or VPA3
Data is from the selected VPA
MOTOR Data is a motor measurement result (only the Data field is
used with this source, any other fields are ignored)
IN Data is from the IN efficiency group (or starts at this group if
2nd Measurement Source is MIDDLE or OUT)
MIDDLE Data is from the MIDDLE efficiency group (or starts at this
group if 2nd Measurement Source is OUT)
OUT Data is from the OUT efficiency group
2nd Measurement
Source (ignored if
Measurement Source is
a single channel or is
MOTOR)
KEYWORD MIDDLE Data is to the MIDDLE efficiency group (only valid if
Measurement Source is IN)
OUT Data is to the OUT efficiency group (only valid if
Measurement Source is IN or MIDDLE)
Data is from the 1st through 4th (resp.) channel of the
selected VPA
pAC Data is the voltage measured between phases A and C of
the selected VPA
M2000 SERIES OPERATION MANUAL
SECTION 10: REMOTE CONTROL
Entire Contents Copyright 2019
M2000 Series Power Analyzers Operation Manual Page 267 of 284
Sub-Field Sub-field
Format
Value Description
pAB Data is the voltage measured between phases A and B of
the selected VPA
pBC Data is the voltage measured between phases B and C of
the selected VPA
pN Data is the neutral current of the selected VPA
WYE
DELTA
SEQZERO Data is the zero sequence data of the selected VPA
SEQPOS Data is the positive sequence data of the selected VPA
SEQNEG Data is the negative sequence data of the selected VPA
TOTAL or
AVERAGE
DEFAULT if no other 2nd Measurement Source sub-field
found
Measurement Type KEYWORD DC Data is the DC component
AC Data is the AC component
ACDC or RMS Data is the ACDC component
COUPLED DEFAULT if no other Measurement Type sub-field found
Data is the DC, AC
or ACDC
component as
COUPLING setting
RECTIFIED Data is the average rectified (ACDC)
STBY Data is the average standby power measurement (ACDC)
STBYMIN Data is the minimum standby power measurement (ACDC)
STBYMAX Data is the maximum standby power measurement (ACDC)
STBYCFMIN Data is the minimum crest factor standby power
measurement (ACDC)
STBYCFMAX Data is the maximum crest factor standby power
measurement (ACDC)
STBYTHDMAX Data is the maximum THD standby power measurement (as
the percentage of the fundamental)
STBYSLOPE Data is the slope (in W/sec) of the standby power
measurement
FF Data is the form factor (ACDC)
CF Data is the crest factor (ACDC)
PK Data is peak (ACDC)
VALLEY Data is valley peak (ACDC)
PK-VLY Data is the difference between peak and valley peak
HIPK Data is the highest peak (including polarity, ACDC)
LOPK Data is the lowest peak (including polarity, ACDC)
THDF Data is THD relative to fundamental amplitude (in %)
THDSIG Data is THD relative to ACDC amplitude (in %)
Data is harmonic amplitude data for the specified harmonic
Data is harmonic phase data for the specified harmonic (in
degrees with ±180° range)
INRUSH Data is the inrush data (max hold, ACDC)
INRUSHPK Data is the peak inrush data (max hold, PK data)
INRUSHVLY Data is the valley peak inrush data (min hold, VALLEY data)
INTEG Data is the integrated data (as COUPLING setting)
INTAVG Data is the average integrated data (as COUPLING setting)
CHARGE Data is the integrated charge data (DC only)
DISCHARGE Data is the integrated discharge data (DC only)
BOUGHT Data is the integrated bought data (as COUPLING setting)
SOLD Data is the integrated sold data (as COUPLING setting)
Data is as Hn but expressed as a percentage of the
fundamental
Data is as Hn but expressed as a percentage of the ACDC
amplitude
M2000 SERIES OPERATION MANUAL
SECTION 10: REMOTE CONTROL
Entire Contents Copyright 2019
M2000 Series Power Analyzers Operation Manual Page 268 of 284
Sub-Field Sub-field
Format
Value Description
THC Total Harmonic Current (only valid when used with AMPS
data for a channel)
POHC Partial Odd Harmonic Current (only valid when used with
AMPS data for a channel)
PWHC Partial Weighted Harmonic Current (only valid when used
with AMPS data for a channel)
Ending Harmonic (only
used if Measurement
NR1 1 to 500 Data includes harmonics up to and including this number (if
this sub-field is not specified then data only includes the
single harmonic specified in the Measurement Type subfield)
A list of allowed combinations is provided below. In this list the following codes are used to reduce the length of
the list:
CHn Any of CH1, CH2, CH3 or CH4
An Any of A1, A2 or A3
pX Any of pA, pB, pC or pD
Hn
N
Pn
%n
Not all combinations shown may be allowed under all circumstances. Channels might not be installed or the
configuration may not provide valid results for a specific combination. Not all valid combinations may be shown
below and where a default sub-field value may be used, the combination is only shown without defining that
specific sub-field.
FREQ:CHn VOLTS:An:pX:THDsig VOLTS:An:INTAVG:H1 AMPS:An:pX:SOLD
FREQ:CHn:STBYMIN VOLTS:An:pX:%n VOLTS:An:CHARGE AMPS:An:pX:Hn
FREQ:CHn:STBYMAX VOLTS:An:pX:%n:n VOLTS:An:DISCHARGE AMPS:An:pX:Hn:n
FREQ:An VOLTS:An:pAC:AC VOLTS:An:BOUGHT AMPS:An:pX:Pn
INTEGTIME:CHn:INTEG VOLTS:An:pAC:ACDC VOLTS:An:SOLD AMPS:An:pX:THDf
INTEGTIME:CHn:CHARGE VOLTS:An:pAC VOLTS:An:H1 AMPS:An:pX:THDsig
INTEGTIME:CHn:DISCHARGE VOLTS:An:pAC:RECTIFIED VPH-PH:CHn:DC AMPS:An:pX:%n
INTEGTIME:CHn:BOUGHT VOLTS:An:pAC:FF VPH-PH:CHn:AC AMPS:An:pX:%n:n
INTEGTIME:CHn:SOLD VOLTS:An:pAC:CF VPH-PH:CHn:ACDC AMPS:An:pN:DC
INTEGTIME:An:INTEG VOLTS:An:pAC:PK VPH-PH:CHn AMPS:An:pN:AC
INTEGTIME:An:CHARGE VOLTS:An:pAC:HIPK VPH-PH:CHn:RECTIFIED AMPS:An:pN:ACDC
INTEGTIME:An:DISCHARGE VOLTS:An:pAC:LOPK VPH-PH:CHn:FF AMPS:An:pN
INTEGTIME:An:BOUGHT VOLTS:An:pAC:INRUSH VPH-PH:CHn:CF AMPS:An:pN:RECTIFIED
INTEGTIME:An:SOLD VOLTS:An:pAC:INRUSHPK VPH-PH:CHn:PK AMPS:An:pN:FF
STBYTIME:CHn VOLTS:An:pAC:INTEG VPH-PH:CHn:Hn AMPS:An:pN:CF
STBYTIME:An VOLTS:An:pAC:INTAVG VPH-PH:CHn:Hn:n AMPS:An:pN:PK
VOLTS:CHn:DC VOLTS:An:pAC:BOUGHT VPH-PH:CHn:THDf AMPS:An:pN:INRUSH
VOLTS:CHn:AC VOLTS:An:pAC:SOLD VPH-PH:CHn:THDsig AMPS:An:pN:INRUSHPK
VOLTS:CHn:ACDC VOLTS:An:pAC:Hn VPH-PH:CHn:%n AMPS:An:pN:Hn
VOLTS:CHn VOLTS:An:pAC:Hn:n VPH-PH:CHn:%n:n AMPS:An:pN:Hn:n
VOLTS:CHn:RECTIFIED VOLTS:An:pAC:Pn AMPS:CHn:DC AMPS:An:pN:Pn
VOLTS:CHn:FF VOLTS:An:pAC:THDf AMPS:CHn:AC AMPS:An
VOLTS:CHn:CF VOLTS:An:pAC:THDsig AMPS:CHn:ACDC AMPS:An:RECTIFIED
VOLTS:CHn:PK VOLTS:An:pAC:%n AMPS:CHn AMPS:An:PK
VOLTS:CHn:VALLEY VOLTS:An:pAC:%n:n AMPS:CHn:RECTIFIED AMPS:An:INRUSH
VOLTS:CHn:PK-VLY VOLTS:An:pBC:AC AMPS:CHn:FF AMPS:An:INRUSHPK
VOLTS:CHn:HIPK VOLTS:An:pBC:ACDC AMPS:CHn:CF AMPS:An:INTEG
VOLTS:CHn:LOPK VOLTS:An:pBC AMPS:CHn:PK AMPS:An:INTAVG
VOLTS:CHn:INRUSH VOLTS:An:pBC:RECTIFIED AMPS:CHn:VALLEY AMPS:An:INTEG:H1
VOLTS:CHn:INRUSHPK VOLTS:An:pBC:FF AMPS:CHn:PK-VLY AMPS:An:INTAVG:H1
VOLTS:CHn:INRUSHVLY VOLTS:An:pBC:CF AMPS:CHn:HIPK AMPS:An:CHARGE
M2000 SERIES OPERATION MANUAL
SECTION 10: REMOTE CONTROL
Entire Contents Copyright 2019
M2000 Series Power Analyzers Operation Manual Page 269 of 284
VOLTS:CHn:INTEG VOLTS:An:pBC:PK AMPS:CHn:LOPK AMPS:An:DISCHARGE
VOLTS:CHn:INTAVG VOLTS:An:pBC:HIPK AMPS:CHn:INRUSH AMPS:An:SEQZERO
VOLTS:CHn:INTEG:H1 VOLTS:An:pBC:LOPK AMPS:CHn:INRUSHPK AMPS:An:SEQPOS
VOLTS:CHn:INTAVG:H1 VOLTS:An:pBC:INRUSH AMPS:CHn:INRUSHVLY AMPS:An:SEQNEG
VOLTS:CHn:CHARGE VOLTS:An:pBC:INRUSHPK AMPS:CHn:INTEG AMPS:An:BOUGHT
VOLTS:CHn:DISCHARGE VOLTS:An:pBC:INTEG AMPS:CHn:INTAVG AMPS:An:SOLD
VOLTS:CHn:BOUGHT VOLTS:An:pBC:INTAVG AMPS:CHn:INTEG:H1 AMPS:An:H1
VOLTS:CHn:SOLD VOLTS:An:pBC:BOUGHT AMPS:CHn:INTAVG:H1 WATTS:CHn:DC
VOLTS:CHn:Hn VOLTS:An:pBC:SOLD AMPS:CHn:CHARGE WATTS:CHn:AC
VOLTS:CHn:Hn:n VOLTS:An:pBC:Hn AMPS:CHn:DISCHARGE WATTS:CHn:ACDC
VOLTS:CHn:Pn VOLTS:An:pBC:Hn:n AMPS:CHn:BOUGHT WATTS:CHn
VOLTS:CHn:THDf VOLTS:An:pBC:Pn AMPS:CHn:SOLD WATTS:CHn:Hn
VOLTS:CHn:THDsig VOLTS:An:pBC:THDf AMPS:CHn:Hn WATTS:CHn:Hn:n
VOLTS:CHn:%n VOLTS:An:pBC:THDsig AMPS:CHn:Hn:n WATTS:CHn:%n
VOLTS:CHn:%n:n VOLTS:An:pBC:%n AMPS:CHn:Pn WATTS:CHn:INRUSH
VOLTS:CHn:STBY VOLTS:An:pBC:%n:n AMPS:CHn:THDf WATTS:CHn:INTEG
VOLTS:CHn:STBYMIN VOLTS:An:pAB:AC AMPS:CHn:THDsig WATTS:CHn:INTAVG
VOLTS:CHn:STBYMAX VOLTS:An:pAB:ACDC AMPS:CHn:%n WATTS:CHn:INTEG:H1
VOLTS:CHn:STBYCFMIN VOLTS:An:pAB AMPS:CHn:%n:n WATTS:CHn:INTAVG:H1
VOLTS:CHn:STBYCFMAX VOLTS:An:pAB:RECTIFIED AMPS:CHn:STBY WATTS:CHn:CHARGE
VOLTS:CHn:STBYTHDMAX VOLTS:An:pAB:FF AMPS:CHn:STBYMIN WATTS:CHn:DISCHARGE
VOLTS:An:pX:DC VOLTS:An:pAB:CF AMPS:CHn:STBYMAX WATTS:CHn:BOUGHT
VOLTS:An:pX:AC VOLTS:An:pAB:PK AMPS:CHn:STBYCFMAX WATTS:CHn:SOLD
VOLTS:An:pX:ACDC VOLTS:An:pAB:INRUSH AMPS:CHn:THC WATTS:CHn:STBY
VOLTS:An:pX VOLTS:An:pAB:INRUSHPK AMPS:CHn:POHC WATTS:CHn:STBYMIN
VOLTS:An:pX:RECTIFIED VOLTS:An:pAB:Hn AMPS:CHn:PWHC WATTS:CHn:STBYMAX
VOLTS:An:pX:FF VOLTS:An:pAB:Hn:n AMPS:An:pX:DC WATTS:CHn:STBYSLOPE
VOLTS:An:pX:CF VOLTS:An:pAB:Pn AMPS:An:pX:AC WATTS:An:pX:DC
VOLTS:An:pX:PK VOLTS:An:pAB:THDf AMPS:An:pX:ACDC WATTS:An:pX:AC
VOLTS:An:pX:HIPK VOLTS:An:pAB:THDsig AMPS:An:pX WATTS:An:pX:ACDC
VOLTS:An:pX:LOPK VOLTS:An:pAB:%n AMPS:An:pX:RECTIFIED WATTS:An:pX
VOLTS:An:pX:INRUSH VOLTS:An:pAB:%n:n AMPS:An:pX:FF WATTS:An:pX:H1
VOLTS:An:pX:INRUSHPK VOLTS:An:SEQZERO AMPS:An:pX:CF WATTS:An:pX:INRUSH
VOLTS:An:pX:INTEG VOLTS:An:SEQPOS AMPS:An:pX:PK WATTS:An:pX:INTEG
VOLTS:An:pX:INTAVG VOLTS:An:SEQNEG AMPS:An:pX:HIPK WATTS:An:pX:INTAVG
VOLTS:An:pX:INTEG:H1 VOLTS:An:WYE AMPS:An:pX:LOPK WATTS:An:pX:INTEG:H1
VOLTS:An:pX:INTAVG:H1 VOLTS:An:DELTA AMPS:An:pX:INRUSH WATTS:An:pX:INTAVG:H1
VOLTS:An:pX:CHARGE VOLTS:An AMPS:An:pX:INRUSHPK WATTS:An:pX:CHARGE
VOLTS:An:pX:DISCHARGE VOLTS:An:RECTIFIED AMPS:An:pX:INTEG WATTS:An:pX:DISCHARGE
VOLTS:An:pX:BOUGHT VOLTS:An:PK AMPS:An:pX:INTAVG WATTS:An:pX:BOUGHT
VOLTS:An:pX:SOLD VOLTS:An:INRUSH AMPS:An:pX:INTEG:H1 WATTS:An:pX:SOLD
VOLTS:An:pX:Hn VOLTS:An:INRUSHPK AMPS:An:pX:INTAVG:H1 WATTS:An:pAC:DC
VOLTS:An:pX:Hn:n VOLTS:An:INTEG AMPS:An:pX:CHARGE WATTS:An:pAC:AC
VOLTS:An:pX:Pn VOLTS:An:INTAVG AMPS:An:pX:DISCHARGE WATTS:An:pAC:ACDC
VOLTS:An:pX:THDf VOLTS:An:INTEG:H1 AMPS:An:pX:BOUGHT WATTS:An:pAC
WATTS:An:pAC:H1 VAR:CHn:SOLD VA:An:pX:ACDC PF:CHn:STBY
WATTS:An:pAC:INRUSH VAR:An:pX:AC VA:An:pX PF:CHn:STBYMIN
WATTS:An:pAC:INTEG VAR:An:pX:ACDC VA:An:pX:H1 PF:CHn:STBYMAX
WATTS:An:pAC:INTAVG VAR:An:pX VA:An:pX:INTEG PF:An:pX:AC
WATTS:An:pAC:CHARGE VAR:An:pX:H1 VA:An:pX:INTAVG PF:An:pX:ACDC
WATTS:An:pAC:DISCHAR
GE
VAR:An:pX:INTEG VA:An:pX:INTEG:H1 PF:An:pX
WATTS:An:pAC:BOUGHT VAR:An:pX:INTAVG VA:An:pX:INTAVG:H1 PF:An:pX:INTAVG
WATTS:An:pAC:SOLD VAR:An:pX:INTEG:H1 VA:An:pX:CHARGE PF:An:pX:INTAVG:H1
WATTS:An:pBC:DC VAR:An:pX:INTAVG:H1 VA:An:pX:DISCHARGE PF:An:pX:H1
WATTS:An:pBC:AC VAR:An:pX:BOUGHT VA:An:pX:BOUGHT PF:An:pAC:AC
WATTS:An:pBC:ACDC VAR:An:pX:SOLD VA:An:pX:SOLD PF:An:pAC:ACDC
WATTS:An:pBC VAR:An:pAC:AC VA:An:pAC:DC PF:An:pAC
WATTS:An:pBC:H1 VAR:An:pAC:ACDC VA:An:pAC:AC PF:An:pAC:INTAVG
WATTS:An:pBC:INRUSH VAR:An:pAC VA:An:pAC:ACDC PF:An:pAC:H1
M2000 SERIES OPERATION MANUAL
SECTION 10: REMOTE CONTROL
Entire Contents Copyright 2019
M2000 Series Power Analyzers Operation Manual Page 270 of 284
WATTS:An:pBC:INTEG VAR:An:pAC:H1 VA:An:pAC PF:An:pBC:AC
WATTS:An:pBC:INTAVG VAR:An:pAC:INTEG VA:An:pAC:H1 PF:An:pBC:ACDC
WATTS:An:pBC:CHARGE VAR:An:pAC:INTAVG VA:An:pAC:INTEG PF:An:pBC
WATTS:An:pBC:DISCHAR
GE
VAR:An:pAC:BOUGHT VA:An:pAC:INTAVG PF:An:pBC:INTAVG
WATTS:An:pBC:BOUGHT VAR:An:pAC:SOLD VA:An:pAC:CHARGE PF:An:pBC:H1
WATTS:An:pBC:SOLD VAR:An:pBC:AC VA:An:pAC:DISCHARGE PF:An:AC
WATTS:An:DC VAR:An:pBC:ACDC VA:An:pAC:BOUGHT PF:An:ACDC
WATTS:An:AC VAR:An:pBC VA:An:pAC:SOLD PF:An
WATTS:An:ACDC VAR:An:pBC:H1 VA:An:pBC:DC PF:An:INTAVG
WATTS:An VAR:An:pBC:INTEG VA:An:pBC:AC PF:An:INTAVG:H1
WATTS:An:H1 VAR:An:pBC:INTAVG VA:An:pBC:ACDC PF:An:H1
WATTS:An:INRUSH VAR:An:pBC:BOUGHT VA:An:pBC PHASE:CHn:AC
WATTS:An:INTEG VAR:An:pBC:SOLD VA:An:pBC:H1 PHASE:CHn:H1
WATTS:An:INTAVG VAR:An:AC VA:An:pBC:INTEG PHASE:An:pX:AC
WATTS:An:INTEG:H1 VAR:An:ACDC VA:An:pBC:INTAVG PHASE:An:pX:H1
WATTS:An:INTAVG:H1 VAR:An VA:An:pBC:CHARGE PHASE:An:pAC:AC
WATTS:An:CHARGE VAR:An:H1 VA:An:pBC:DISCHARGE PHASE:An:pAC:H1
WATTS:An:DISCHARGE VAR:An:INTEG VA:An:pBC:BOUGHT PHASE:An:pBC:AC
WATTS:An:BOUGHT VAR:An:INTAVG VA:An:pBC:SOLD PHASE:An:pBC:H1
WATTS:An:SOLD VAR:An:INTEG:H1 VA:An:DC PHASE:An:AC
WATTS:IN VAR:An:INTAVG:H1 VA:An:AC PHASE:An:H1
WATTS:MIDDLE VAR:An:BOUGHT VA:An:ACDC LOADZ:CHn:DC
WATTS:OUT VAR:An:SOLD VA:An LOADZ:CHn:AC
LOSS:IN:MIDDLE VA:CHn:DC VA:An:H1 LOADZ:CHn:ACDC
LOSS:IN:OUT VA:CHn:AC VA:An:INTEG LOADZ:CHn
LOSS:MIDDLE:OUT VA:CHn:ACDC VA:An:INTAVG LOADZ:CHn:H1
EFFICIENCY:IN:MIDDLE VA:CHn VA:An:INTEG:H1 SERIESR:CHn:AC
EFFICIENCY:IN:OUT VA:CHn:H1 VA:An:INTAVG:H1 SERIESR:CHn:H1
EFFICIENCY:MIDDLE:OUT VA:CHn:INTEG VA:An:CHARGE SERIESL:CHn:AC
VAR:CHn:AC VA:CHn:INTAVG VA:An:DISCHARGE SERIESL:CHn:H1
VAR:CHn:ACDC VA:CHn:INTEG:H1 VA:An:BOUGHT PARALLELR:CHn:AC
VAR:CHn VA:CHn:INTAVG:H1 VA:An:SOLD PARALLELR:CHn:H1
VAR:CHn:H1 VA:CHn:CHARGE PF:CHn:AC PARALLELC:CHn:AC
VAR:CHn:INTEG VA:CHn:DISCHARGE PF:CHn:ACDC PARALLELC:CHn:H1
VAR:CHn:INTAVG VA:CHn:BOUGHT PF:CHn STBYERR:CHn:STBY
VAR:CHn:INTEG:H1 VA:CHn:SOLD PF:CHn:INTAVG STBYERR:CHn:STBYMIN
VAR:CHn:INTAVG:H1 VA:An:pX:DC PF:CHn:INTAVG:H1
VAR:CHn:BOUGHT VA:An:pX:AC PF:CHn:H1
M2000 SERIES OPERATION MANUAL
SECTION 10: REMOTE CONTROL
Entire Contents Copyright 2019
M2000 Series Power Analyzers Operation Manual Page 271 of 284
10.5.11 DDEF Measurement Definition Field Sub-Fields
This field consist of one to five sub-fields, each separated by the sub-field separator (colon
character). The sub-fields may be specified in any order and may optionally be omitted (a
default value being used as needed).
Sub-Field Sub-field
Format
Value Description
Measurement
Data
KEYWORD FREQ Signal frequency (in Hz)
VOLTS or V Voltage (in V)
AMPS or A Current (in A)
WATTS or W DEFAULT if no other Measurement Data sub-field found
Real power (in W)
LOSS Real power loss (in W)
EFFICIENCY or EFF Real power efficiency (in %)
VAR Imaginary power (in W)
VA Apparent power (in VA)
PF Power factor
SPEED Motor speed (in rpm)
SLIP Motor slip (in %)
TORQUE Motor torque (in Nm)
LOADZ Load impedance (in ohms)
Measurement
Source
KEYWORD CH1, CH2, CH3 or CH4 CH1 is DEFAULT if no other Measurement Source sub-field found
Data is from the selected channel
A1, A2, A3, VPA1,
VPA2 or VPA3
Data is from the selected VPA
MOTOR Data is a motor measurement result (only the Data field is used
with this, any other fields are ignored)
IN Data is from the IN efficiency group
MIDDLE Data is from the MIDDLE efficiency group
OUT Data is from the OUT efficiency group
IN-MID Data is from the IN efficiency group to the MIDDLE efficiency
group
IN-OUT Data is from the IN efficiency group to the OUT efficiency group
MID-OUT Data is from the MIDDLE efficiency group to the OUT efficiency
group
2nd
Measurement
Source (ignored
if Measurement
Source is not a
VPA)
KEYWORD Data is from the 1st through 4th (resp.) channel of the selected
VPA
pAC Data is the voltage measured between phases A and C of the
selected VPA
pAB Data is the voltage measured between phases A and B of the
selected VPA
pBC Data is the voltage measured between phases B and C of the
selected VPA
pN Data is the neutral current of the selected VPA
TOTAL or AVERAGE DEFAULT if no other 2nd Measurement Source sub-field found
Data is the total for the selected VPA, except for VOLTS and
AMPS data which is the average of all channels/phases in the
selected VPA
Measurement
Type
KEYWORD DC Data is the DC component
AC Data is the AC component
ACDC or RMS Data is the ACDC component
COUPLED DEFAULT if no other Measurement Type sub-field found
Data is the DC, AC or ACDC component as configured for the VPA
CF Data is the crest factor (ACDC)
PK Data is peak (ACDC)
VALLEY Data is valley peak
PK-VLY Data is the difference between peak and valley peak
M2000 SERIES OPERATION MANUAL
SECTION 10: REMOTE CONTROL
Entire Contents Copyright 2019
M2000 Series Power Analyzers Operation Manual Page 272 of 284
Sub-Field Sub-field
Format
Value Description
HIPK Data is the highest peak (including polarity, ACDC coupled)
LOPK Data is the lowest peak (including polarity, ACDC coupled)
THDF Data is THD relative to fundamental amplitude (in %)
THDSIG Data is THD relative to ACDC amplitude (in %)
H1 or H2 or H3 Data is harmonic amplitude data for the 1st, 2nd or 3rd harmonic
respectively
P1 Data is harmonic phase data for the fundamental (in degrees with
±180° range)
HLIST Data is a list of the harmonic amplitudes for each harmonic.
This may only be used with the LOGDATA command, and only
with a channel Measurement Source, and only with voltage or
current Measurement Data.
Ending
Harmonic (only
used if
Measurement
Type is HLIST)
NR1 1 to 500 This sub-field is only used with a Measurement Type of HLIST. If
present, it is ignored for other measurement types.
Data includes harmonics up to and including this number (if this
sub-field is not specified then the data includes all allowable
harmonics)
A list of allowed combinations is provided below. In this list, the following codes are used to reduce the length of
the list
CHn Any of CH1, CH2, CH3 or CH4
An Any of A1, A2 or A3
pX Any of pA, pB, pC or pD
Hn
Not all combinations shown may be allowed in all circumstances; channels might not be installed or the
configuration may not provide valid results for a specific combination. Not all valid combinations may be shown
below and where a default sub-field value may be used the combination is only shown without defining that
specific sub-field.
FREQ:CHn VOLTS:CHn:LOPK VOLTS:An:pX:CF VOLTS:An:pAC:CF
FREQ:An VOLTS:CHn:Hn VOLTS:An:pX:PK VOLTS:An:pAC:PK
VOLTS:CHn:DC VOLTS:CHn:P1 VOLTS:An:pX:HIPK VOLTS:An:pAC:HIPK
VOLTS:CHn:AC VOLTS:CHn:THDf VOLTS:An:pX:LOPK VOLTS:An:pAC:LOPK
VOLTS:CHn:ACDC VOLTS:CHn:THDsig VOLTS:An:pX:Hn VOLTS:An:pAC:Hn
VOLTS:CHn VOLTS:CHn:HLIST VOLTS:An:pX:P1 VOLTS:An:pAC:P1
VOLTS:CHn:CF VOLTS:CHn:HLIST:n VOLTS:An:pX:THDf VOLTS:An:pAC:THDf
VOLTS:CHn:PK VOLTS:An:pX:DC VOLTS:An:pX:THDsig VOLTS:An:pAC:THDsig
VOLTS:CHn:VALLEY VOLTS:An:pX:AC VOLTS:An:pAC:AC VOLTS:An:pBC:AC
VOLTS:CHn:PK-VLY VOLTS:An:pX:ACDC VOLTS:An:pAC:ACDC VOLTS:An:pBC:ACDC
VOLTS:CHn:HIPK VOLTS:An:pX VOLTS:An:pAC VOLTS:An:pBC
VOLTS:An:pBC:CF AMPS:An:pX:PK WATTS:An:H1 VA:An:pAC:AC
VOLTS:An:pBC:PK AMPS:An:pX:HIPK WATTS:IN VA:An:pAC:ACDC
VOLTS:An:pBC:HIPK AMPS:An:pX:LOPK WATTS:MIDDLE VA:An:pAC
VOLTS:An:pBC:LOPK AMPS:An:pX:Hn WATTS:OUT VA:An:pAC:H1
VOLTS:An:pBC:Hn AMPS:An:pX:P1 LOSS:IN-MID VA:An:pBC:DC
VOLTS:An:pBC:P1 AMPS:An:pX:THDf LOSS:IN-OUT VA:An:pBC:AC
VOLTS:An:pBC:THDf AMPS:An:pX:THDsig LOSS:MID-OUT VA:An:pBC:ACDC
VOLTS:An:pBC:THDsig AMPS:An:pN:DC EFFICIENCY:IN-MID VA:An:pBC
VOLTS:An:pAB:AC AMPS:An:pN:AC EFFICIENCY:IN-OUT VA:An:pBC:H1
VOLTS:An:pAB:ACDC AMPS:An:pN:ACDC EFFICIENCY:MID-OUT VA:An:DC
VOLTS:An:pAB AMPS:An:pN VAR:CHn:AC VA:An:AC
VOLTS:An:pAB:CF AMPS:An:pN:CF VAR:CHn:ACDC VA:An:ACDC
VOLTS:An:pAB:PK AMPS:An:pN:PK VAR:CHn VA:An
VOLTS:An:pAB:Hn AMPS:An:pN:H1 VAR:CHn:H1 VA:An:H1
VOLTS:An:pAB:P1 AMPS:An VAR:An:pX:AC PF:CHn:AC
VOLTS:An:pAB:THDf AMPS:An:PK VAR:An:pX:ACDC PF:CHn:ACDC
VOLTS:An:pAB:THDsig AMPS:An:H1 VAR:An:pX PF:CHn
M2000 SERIES OPERATION MANUAL
SECTION 10: REMOTE CONTROL
Entire Contents Copyright 2019
M2000 Series Power Analyzers Operation Manual Page 273 of 284
VOLTS:An WATTS:CHn:DC VAR:An:pX:H1 PF:CHn:H1
VOLTS:An:PK WATTS:CHn:AC VAR:An:pAC:AC PF:An:pX:AC
VOLTS:An:H1 WATTS:CHn:ACDC VAR:An:pAC:ACDC PF:An:pX:ACDC
AMPS:CHn:DC WATTS:CHn VAR:An:pAC PF:An:pX
AMPS:CHn:AC WATTS:CHn:H1 VAR:An:pAC:H1 PF:An:pX:H1
AMPS:CHn:ACDC WATTS:An:pX:DC VAR:An:pBC:AC PF:An:pAC:AC
AMPS:CHn WATTS:An:pX:AC VAR:An:pBC:ACDC PF:An:pAC:ACDC
AMPS:CHn:CF WATTS:An:pX:ACDC VAR:An:pBC PF:An:pAC
AMPS:CHn:PK WATTS:An:pX VAR:An:pBC:H1 PF:An:pAC:H1
AMPS:CHn:VALLEY WATTS:An:pX:H1 VAR:An:AC PF:An:pBC:AC
AMPS:CHn:PK-VLY WATTS:An:pAC:DC VAR:An:ACDC PF:An:pBC:ACDC
AMPS:CHn:HIPK WATTS:An:pAC:AC VAR:An PF:An:pBC
AMPS:CHn:LOPK WATTS:An:pAC:ACDC VAR:An:H1 PF:An:pBC:H1
AMPS:CHn:Hn WATTS:An:pAC VA:CHn:DC PF:An:AC
AMPS:CHn:P1 WATTS:An:pAC:H1 VA:CHn:AC PF:An:ACDC
AMPS:CHn:THDf WATTS:An:pBC:DC VA:CHn:ACDC PF:An
AMPS:CHn:THDsig WATTS:An:pBC:AC VA:CHn PF:An:H1
AMPS:CHn:HLIST WATTS:An:pBC:ACDC VA:CHn:H1 LOADZ:CHn:DC
AMPS:CHn:HLIST:n WATTS:An:pBC VA:An:pX:DC LOADZ:CHn:AC
AMPS:An:pX:DC WATTS:An:pBC:H1 VA:An:pX:AC LOADZ:CHn:ACDC
AMPS:An:pX:AC WATTS:An:DC VA:An:pX:ACDC LOADZ:CHn
AMPS:An:pX:ACDC WATTS:An:AC VA:An:pX LOADZ:CHn:H1
AMPS:An:pX WATTS:An:ACDC VA:An:pX:H1
AMPS:An:pX:CF WATTS:An VA:An:pAC:DC
M2000 SERIES OPERATION MANUAL
SECTION 11: CALIBRATION
Entire Contents Copyright 2019
M2000 Series Power Analyzers Operation Manual Page 274 of 284
11
11.1 Overview
Calibration adjustment should be rarely needed; however you may wish to perform it at periodic
intervals to ensure optimal performance.
The M2000 employs internal software calibration adjustments, there are no physical
adjustments required. These adjustments are needed to correct for manufacturing
tolerances in the components used in the M2000.
It is important to note that there is no calibration of electro-mechanical performance
(e.g. high frequency response) or design defects, giving you a high degree of certainty
that the M2000
Calibration adjustment can only be performed via an interface using a Windows
application program provided by the manufacturer. This application does not control
the source of the voltage or current being used for adjustment, it only controls the
M2000. You should ensure:
The computer used has a suitable interface installed.
The computer used has the supplied M2000 calibration adjustment application
installed.
The M2000 has been properly configured for the interface chosen.
Calibration adjustment should only be performed after the M2000 has been
continuously powered in a stable environment for at least 1 hour. If the M2000 has
been moved between differing environments, then at least 3 hours should be allowed.
In the procedure below, each installed channel is calibrated separately and the
procedure varies automatically depending on the channel type (the 1st letter of the
channel code) and the channel current option (the 2nd letter of the channel code).
The supplied application automatically saves the measurement configuration of the
M2000 prior to reconfiguring it for calibration adjustments and restores the saved
configuration after calibration adjustment has been completed.
The M2000 may be adjusted at any frequency between 45 and 450Hz. It normally
produces the optimum results to calibrate the M2000 at 50, 55 or 60Hz. At these
frequencies the specifications of the source are typically the most accurate. When
calibrating at very low signal levels you may experience interference from the local
mains supply, in these cases it is recommended to adjust the M2000 at a frequency of
other than the local mains supply. The accuracy difference in the M2000 between 50, 55
or 60Hz is extremely small and may be ignored, and the difference between performing
the adjustments at near mains frequency vs. 400Hz for aerospace applications may also
be disregarded as the difference in the M2000 accuracy is negligible at the adjustment
levels.

ChatGPT
Remote Control and Commands Guide
Thought for 2m 41s
Below is a collection of minimal Python examples showing how you might:

Open communication with the M2000 Analyzer (APSM2000)
Enter remote-control mode (the M2000 automatically goes into REMOTE once it receives any valid command)
Send a command to read the voltages on all installed channels (CH1 through CH4)
Retrieve and parse the response
These examples assume you are only retrieving voltage data from each channel as an illustration. Obviously, you can send any other commands in a similar manner (e.g., configuration commands, reading current, power, etc.).

Important:

These snippets are starting points. In a real application, you would add error-handling, timeouts, robust string parsing, and so forth.
You must consult your Python environment’s versions of libraries (e.g., pyserial, built-in socket, or vendor-provided HID DLL wrappers) and adapt the snippets as needed.
1. Using RS232 (via Python pyserial)
1.1 Physical Connection
You will need an RS232 null-modem cable (female–female) with full handshaking lines (RTS, CTS, DTR, DSR) crossing over as described in the manual.
Ensure the M2000’s Baud Rate, Handshake, etc., match your code.
If you are using a USB-to-RS232 adapter, confirm the COM port number in your OS and that the adapter drivers are installed properly.
1.2 Python Example
python
Copy code
import serial
import time

def read_voltages_via_rs232(port_name="COM1", baud_rate=115200):
    """
    Example of opening an RS232 port via pyserial,
    sending a command to read all channel voltages,
    and printing the response.
    """
    # Configure the serial port
    ser = serial.Serial()
    ser.port = port_name       # e.g., "COM1", "COM4", "/dev/ttyUSB0", etc.
    ser.baudrate = baud_rate   # Must match your M2000 setting
    ser.bytesize = serial.EIGHTBITS
    ser.parity   = serial.PARITY_NONE
    ser.stopbits = serial.STOPBITS_ONE
    ser.timeout  = 1.0         # seconds read timeout
    # Enable RTS/CTS hardware flow control:
    ser.rtscts   = True
    # DTR must be enabled so M2000 knows a controller is present:
    ser.dtr      = True

    try:
        ser.open()
        # The M2000 goes into remote mode once it receives any valid command.
        # Clear interface and errors:
        ser.write(b"*CLS\n")
        time.sleep(0.2)

        # Example command: read the voltage on channels 1..4.
        # Using the syntax:  READ? VOLTS:CH1, VOLTS:CH2, VOLTS:CH3, VOLTS:CH4
        command = "READ? VOLTS:CH1, VOLTS:CH2, VOLTS:CH3, VOLTS:CH4\n"
        ser.write(command.encode("ascii"))

        # Read back one line of response (terminated by CR,LF typically)
        response_line = ser.readline().decode("ascii").strip()

        print("Raw response:", response_line)

        # The M2000 typically returns comma-separated NR3 fields, e.g.:
        # +1.20000E+01,+2.34567E+01,+3.21000E+01,+4.54321E+01
        # We can split on commas:
        if response_line:
            voltage_strings = response_line.split(',')
            voltages = [float(v) for v in voltage_strings]
            print("Parsed channel voltages:", voltages)
        else:
            print("No response or empty response received.")

    except serial.SerialException as e:
        print("Serial error:", e)
    except Exception as e:
        print("General error:", e)
    finally:
        if ser.is_open:
            ser.close()

if __name__ == "__main__":
    read_voltages_via_rs232(port_name="COM3", baud_rate=115200)
Key Points for RS232 in Python

Use pyserial (pip install pyserial).
Make sure to set rtscts=True and dtr=True if your M2000 is configured for RTS/CTS hardware handshaking and to assert DTR.
Terminate commands with \n (or \r\n).
Read lines with readline().
2. Using LAN (TCP/IP Socket)
2.1 Physical/Network Setup
Connect a standard Ethernet cable from the M2000 to your LAN (or directly to your PC with auto-MDI/MDIX).
Ensure the M2000 has a valid IP Address (manually assigned, via DHCP, or via Auto-IP).
By default, the M2000 listens on TCP port 10733, and it only allows one active TCP connection at a time.
2.2 Python Example
python
Copy code
import socket
import time

def read_voltages_via_tcp(ip_address="192.168.1.100", port=10733):
    """
    Example of opening a TCP/IP socket to the M2000,
    sending a command to read all channel voltages,
    and printing the response.
    """
    # Create a TCP socket
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        # Optional: set a timeout on blocking socket operations
        s.settimeout(2.0)  # seconds

        print(f"Connecting to {ip_address}:{port} ...")
        s.connect((ip_address, port))
        print("Connected.")

        # Clear interface and errors:
        s.sendall(b"*CLS\n")
        time.sleep(0.2)

        # Send the READ? command
        command = "READ? VOLTS:CH1, VOLTS:CH2, VOLTS:CH3, VOLTS:CH4\n"
        s.sendall(command.encode("ascii"))

        # The M2000 typically ends responses with \r\n
        # We'll do a simple recv loop until we get the \n
        response_buffer = []
        while True:
            chunk = s.recv(4096).decode("ascii")
            if not chunk:
                # Connection closed or no data
                break
            response_buffer.append(chunk)
            # If we see a newline, we assume that's the end
            if "\n" in chunk:
                break

        raw_response = "".join(response_buffer).strip()
        print("Raw response:", raw_response)

        # Split on commas
        if raw_response:
            voltage_strings = raw_response.split(',')
            voltages = [float(v) for v in voltage_strings]
            print("Parsed channel voltages:", voltages)
        else:
            print("No response or empty response received.")

if __name__ == "__main__":
    read_voltages_via_tcp("192.168.1.100", 10733)
Key Points for LAN

Use the standard Python socket module.
The M2000 is at IP x.x.x.x on port 10733.
Make sure only one socket connection is open at a time.
If the M2000 does not respond or times out, check its network status, IP address, etc.
3. Using USB (HID Interface)
3.1 Physical Connection
Use a USB A–B cable from your PC’s USB port to the M2000’s USB Type-B port.
The M2000 enumerates as a “Vendor-Specific” HID device (no special driver required on Windows).
You must use the Silicon Labs HID–to–UART DLLs (or a similar library) that the manufacturer provides, or another HID approach.
3.2 Python Example Using the Provided DLLs
Below is a skeletal example using the ctypes module to load the SLABHIDtoUART.dll and SLABHIDDevice.dll that the M2000 manual references. You will need to adjust file paths, handle x86 vs. x64 library details, etc.

python
Copy code
import ctypes
import time
import os

# These constants are from the M2000 manual / Silicon Labs documentation:
VID = 0x10C4  # 4292 in decimal
PID = 0x8805  # 34869 in decimal

# Load the DLLs (adjust the path as needed)
# Make sure these .dll files are accessible to your Python script
dll_path = os.path.abspath(".")  # Example: same folder
hid_dll = ctypes.WinDLL(os.path.join(dll_path, "SLABHIDtoUART.dll"))
# The above call might differ if you’re using a 64-bit Python vs. 32-bit DLL.

# We need a handle type (pointer)
HID_UART_DEVICE = ctypes.c_void_p

# Function prototypes (simplified)
HidUart_GetNumDevices      = hid_dll.HidUart_GetNumDevices
HidUart_Open               = hid_dll.HidUart_Open
HidUart_Close              = hid_dll.HidUart_Close
HidUart_Read               = hid_dll.HidUart_Read
HidUart_Write              = hid_dll.HidUart_Write
HidUart_SetUartConfig      = hid_dll.HidUart_SetUartConfig
HidUart_SetTimeouts        = hid_dll.HidUart_SetTimeouts
HidUart_FlushBuffers       = hid_dll.HidUart_FlushBuffers

# Return codes:
HID_UART_SUCCESS = 0

def open_usb_device(device_index=0):
    """
    Opens the M2000’s USB HID device using the Silicon Labs HID-to-UART driver.
    Returns a valid device handle if successful.
    """
    num_devices = ctypes.c_ulong(0)
    ret = HidUart_GetNumDevices(ctypes.byref(num_devices), VID, PID)
    if ret != HID_UART_SUCCESS:
        raise IOError("HidUart_GetNumDevices failed")

    if num_devices.value == 0:
        raise IOError("No M2000 devices found via USB HID")

    device_handle = HID_UART_DEVICE()
    ret = HidUart_Open(ctypes.byref(device_handle), device_index, VID, PID)
    if ret != HID_UART_SUCCESS:
        raise IOError(f"HidUart_Open failed with code {ret}")

    # Configure the UART side inside the M2000: 115200, 8N1, RTS/CTS, etc.
    # (115200, 8 bits, no parity, 1 stop bit, hardware flow control)
    ret = HidUart_SetUartConfig(
        device_handle,
        ctypes.c_ulong(115200),  # baud rate
        ctypes.c_ubyte(8),       # data bits
        ctypes.c_ubyte(0),       # parity=0 => none
        ctypes.c_ubyte(0),       # stop bits=0 => 1 stop bit
        ctypes.c_ubyte(2)        # flow control=2 => RTS/CTS
    )
    if ret != HID_UART_SUCCESS:
        HidUart_Close(device_handle)
        raise IOError(f"HidUart_SetUartConfig failed with code {ret}")

    # Set timeouts (read=500ms, write=500ms for example)
    ret = HidUart_SetTimeouts(device_handle, 500, 500)
    if ret != HID_UART_SUCCESS:
        HidUart_Close(device_handle)
        raise IOError("HidUart_SetTimeouts failed")

    # Flush any stale buffers
    HidUart_FlushBuffers(device_handle, True, True)

    return device_handle

def close_usb_device(device_handle):
    """Closes the handle to the M2000 USB HID device."""
    if device_handle:
        HidUart_Close(device_handle)

def usb_write(device_handle, cmd_string):
    """
    Writes a string command to the M2000. Must append CR/LF or LF.
    """
    # M2000 typically only needs LF or CR/LF.
    data = (cmd_string + "\n").encode('ascii')
    length = len(data)
    written = ctypes.c_ulong(0)
    ret = HidUart_Write(device_handle, data, length, ctypes.byref(written))
    if ret != HID_UART_SUCCESS:
        raise IOError("HidUart_Write failed")
    if written.value != length:
        raise IOError("Not all bytes were written")

def usb_read_line(device_handle, timeout_sec=2.0):
    """
    Reads a single line from M2000 (until LF) using repeated HidUart_Read calls.
    """
    start = time.time()
    line_bytes = bytearray()

    bufsize = 256
    tempbuf = (ctypes.c_ubyte * bufsize)()
    num_read = ctypes.c_ulong(0)

    while True:
        # Periodically check for timeout
        if (time.time() - start) > timeout_sec:
            raise TimeoutError("USB read timed out waiting for newline")

        # Attempt to read
        ret = HidUart_Read(device_handle, tempbuf, bufsize, ctypes.byref(num_read))
        if ret != HID_UART_SUCCESS:
            raise IOError("HidUart_Read failed")

        if num_read.value > 0:
            # Append to line buffer
            for i in range(num_read.value):
                line_bytes.append(tempbuf[i])
            # Check if we got a LF
            if b'\n' in line_bytes:
                break

        # If no data, small sleep
        time.sleep(0.01)

    # Split at first LF
    line = line_bytes.split(b'\n', 1)[0]
    return line.decode('ascii').strip()

def read_voltages_via_usb():
    """Example usage to read channel voltages over USB HID."""
    device_handle = None
    try:
        device_handle = open_usb_device(device_index=0)

        # Clear interface
        usb_write(device_handle, "*CLS")
        time.sleep(0.2)

        # Request voltages from CH1..CH4
        usb_write(device_handle, "READ? VOLTS:CH1, VOLTS:CH2, VOLTS:CH3, VOLTS:CH4")

        # Read the response line
        response_line = usb_read_line(device_handle, timeout_sec=2.0)
        print("Raw response:", response_line)

        if response_line:
            parts = response_line.split(',')
            voltages = [float(v) for v in parts]
            print("Parsed voltages:", voltages)
        else:
            print("Empty response.")

    except Exception as ex:
        print("Error:", ex)
    finally:
        if device_handle:
            close_usb_device(device_handle)

if __name__ == "__main__":
    read_voltages_via_usb()
Key Points for USB (HID)

You must use the Silicon Labs DLL calls (or a compatible HID library).
The M2000 enumerates as a HID device with Vendor ID (VID = 4292) and Product ID (PID = 34869).
You must enable the same baud rate and flow control settings inside the M2000’s USB–UART bridge layer.
The underlying protocol is still ASCII commands, just encapsulated via HID.
Common Sequence to “Set Remote” and Read Voltages
Regardless of interface (RS232, USB, or LAN), the command sequence is essentially:

Open the connection (serial port, USB handle, or TCP socket).
(Optional) Issue *CLS to reset interface registers, flush errors, etc.
Send any needed configuration commands if desired (e.g., MODE?, ARANGE?, etc.).
Read data with a command such as:
none
Copy code
READ? VOLTS:CH1, VOLTS:CH2, VOLTS:CH3, VOLTS:CH4
Parse the ASCII response from the instrument.
Close the connection when finished (or keep it open for subsequent commands).
The M2000 automatically switches to REMOTE mode upon receiving any valid command. If you need to fully lock the front panel so no user can revert to local, you can also send LOCKOUT. If you ever want to give control back to the front panel from software, you can send LOCAL.

Example “One-Liner” to Read All Voltages
If you simply want a direct read of all four channel voltages, the single ASCII command is:

ruby
Copy code
READ? VOLTS:CH1, VOLTS:CH2, VOLTS:CH3, VOLTS:CH4
The M2000’s response is typically one CSV line:

mathematica
Copy code
+1.23456E+01,+2.34567E+01,+3.45678E+01,+4.56789E+01
Then append \r\n.

Tips & Troubleshooting
DTR/RTS/CTS: Make sure you meet the M2000’s hardware-handshaking requirements (especially via RS232 or certain USB–RS232 adapters). A missing DTR or RTS can cause dropped or ignored commands.
Terminator: The M2000 looks for command terminators (\r, \n, or \0). Usually \n is sufficient.
Multiple Commands: Separate multiple commands in one line with ; or send them in separate writes.
Reading: Wait for the M2000 to finish sending a response before sending a second command that produces a response (to avoid “Tx Overrun” errors).
Timing/Delays: Add small sleeps if you send many commands quickly or have a slower interface (like older USB–serial adapters).
That’s it! You now have three basic Python sketches—one each for RS232, LAN, and USB HID—showing how to put the M2000 (APSM2000) into remote mode, read the voltages, and parse the results. Adapt these further for additional measurements, error handling, or advanced configurations.






You said:
there are only 3 channells i need a comprehesive script for rs232, lan and usb and the exact sintax for the init to get to the remoe enable and the idn format for each comms setup
ChatGPT
Remote Control with RS232, LAN, and USB
Thought for 2m 4s
Below is a single Python file that demonstrates how to:

Initialize communication over RS232, LAN, or USB to an APSM2000 (M2000 family) that has 3 channels installed.
Send the minimal commands to ensure the unit is in REMOTE mode (the M2000 automatically switches to REMOTE upon receiving any valid command).
Request the instrument’s identification string (*IDN?) and parse it.
Optionally lock out the front panel (LOCKOUT) or return it to local (LOCAL).
Important

In the M2000 series, you do not need a dedicated “REMOTE ON” command; sending any valid command over the interface automatically places the instrument in REMOTE mode. If you want to prevent front-panel usage, you can send LOCKOUT.
The exact response format of *IDN? is up to six fields, comma-separated:
Manufacturer (e.g., "Vitrek")
Model (e.g., "M2000" + option flags)
Unit serial number (e.g., "12345")
Firmware major version
Firmware minor version
Firmware build number
Below, we provide three functions—one each for RS232, LAN, and USB—plus a small “main” section. You only call one of these functions depending on which interface you’re using. Each function:

Opens the connection.
Sends *CLS (clears interface registers/errors).
(Optional) Sends LOCKOUT to fully lock out the front panel.
Sends *IDN? and prints/parses the response.
Finally, closes the connection (or you can leave it open if needed).
You can easily adapt these templates to send other commands—such as reading the three channel voltages with

ruby
Copy code
READ? VOLTS:CH1, VOLTS:CH2, VOLTS:CH3
Complete Python Script
python
Copy code
#!/usr/bin/env python3
"""
APSM2000 (M2000 Series) Remote Control Examples
Using RS232, LAN (TCP), or USB (HID) in Python

Demonstrates:
- Basic "init" sequence to ensure REMOTE mode
- Query instrument ID string (*IDN?)
- Optionally LOCKOUT the front panel
- Parse *IDN? response (6 fields)
- Closes the connection

Adapt as needed for your environment.
"""

import time

#############################
# 1. RS232 EXAMPLE (pyserial)
#############################
def init_and_read_idn_rs232(
    port_name="COM1", 
    baud_rate=115200, 
    lock_front_panel=False
):
    """
    Opens RS232 communication to the M2000 via pyserial,
    performs an "init" (clears interface, optionally LOCKOUT),
    requests *IDN?, and parses/prints the ID string.
    """
    import serial  # pip install pyserial

    ser = serial.Serial()
    ser.port = port_name
    ser.baudrate = baud_rate
    ser.bytesize = serial.EIGHTBITS
    ser.parity   = serial.PARITY_NONE
    ser.stopbits = serial.STOPBITS_ONE
    ser.timeout  = 1.0         # read timeout (seconds)
    ser.rtscts   = True        # hardware flow control
    ser.dtr      = True        # must assert DTR so M2000 sees a controller
    
    try:
        ser.open()
        # 1) Clear interface
        ser.write(b"*CLS\n")
        time.sleep(0.1)

        # (Optional) 2) Lock out front panel
        if lock_front_panel:
            ser.write(b"LOCKOUT\n")
            time.sleep(0.1)

        # 3) Request ID
        ser.write(b"*IDN?\n")
        response = ser.readline().decode('ascii').strip()

        print("[RS232] Raw IDN response:", response)
        # The M2000 typically responds with up to six comma-separated fields, e.g.:
        #  Vitrek,M2000/...,12345,2,0,49
        # Let's parse them:
        fields = response.split(',')
        if len(fields) >= 1:
            manufacturer = fields[0]
        if len(fields) >= 2:
            model = fields[1]
        if len(fields) >= 3:
            serial_number = fields[2]
        if len(fields) >= 4:
            fw_major = fields[3]
        if len(fields) >= 5:
            fw_minor = fields[4]
        if len(fields) >= 6:
            fw_build = fields[5]

        print("[RS232] Parsed IDN fields:")
        for i, f in enumerate(fields, start=1):
            print(f"  Field{i} = {f}")

        # Done. Optionally, if you need to revert to local:
        # ser.write(b"LOCAL\n")

    except serial.SerialException as e:
        print("RS232 Serial Error:", e)
    except Exception as e:
        print("General Exception:", e)
    finally:
        if ser.is_open:
            ser.close()


#########################
# 2. LAN (TCP/IP) EXAMPLE
#########################
def init_and_read_idn_lan(
    ip_address="192.168.1.100",
    port=10733,
    lock_front_panel=False
):
    """
    Opens a TCP socket to M2000 at IP:port,
    performs an "init" (clears interface, optionally LOCKOUT),
    requests *IDN?, and parses/prints the ID string.
    """
    import socket

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(2.0)  # 2s timeout for connect/read
    try:
        print(f"[LAN] Connecting to {ip_address}:{port} ...")
        s.connect((ip_address, port))
        print("[LAN] Connected.")

        # 1) Clear interface
        s.sendall(b"*CLS\n")
        time.sleep(0.1)

        # (Optional) 2) Lock out front panel
        if lock_front_panel:
            s.sendall(b"LOCKOUT\n")
            time.sleep(0.1)

        # 3) Request ID
        s.sendall(b"*IDN?\n")
        
        # Read until newline
        response_buffer = []
        while True:
            chunk = s.recv(4096)
            if not chunk:
                break
            response_buffer.append(chunk)
            if b"\n" in chunk:
                break

        raw_response = b"".join(response_buffer).decode("ascii").strip()
        print("[LAN] Raw IDN response:", raw_response)

        # Parse
        fields = raw_response.split(',')
        print("[LAN] Parsed IDN fields:")
        for i, f in enumerate(fields, start=1):
            print(f"  Field{i} = {f}")

        # Done. Optionally revert to local:
        # s.sendall(b"LOCAL\n")

    except socket.timeout:
        print("Socket timed out.")
    except Exception as ex:
        print("LAN error:", ex)
    finally:
        s.close()


###################################
# 3. USB (HID) EXAMPLE (ctypes + DLL)
###################################
def init_and_read_idn_usb(
    device_index=0,
    lock_front_panel=False
):
    """
    Opens USB HID connection using the Silicon Labs HID-to-UART DLL
    (SLABHIDtoUART.dll) as described in the M2000 manual.
    Performs an "init" (clears interface, optionally LOCKOUT),
    requests *IDN?, and parses the response.
    """
    import ctypes
    import os
    # Adjust as needed for your environment and the location of the DLL files
    dll_folder = os.path.abspath(".")
    hid_dll_path = os.path.join(dll_folder, "SLABHIDtoUART.dll")

    # Load the DLL
    hid_dll = ctypes.WinDLL(hid_dll_path)

    # Define function prototypes (abbreviated)
    HidUart_GetNumDevices = hid_dll.HidUart_GetNumDevices
    HidUart_Open          = hid_dll.HidUart_Open
    HidUart_Close         = hid_dll.HidUart_Close
    HidUart_Read          = hid_dll.HidUart_Read
    HidUart_Write         = hid_dll.HidUart_Write
    HidUart_SetUartConfig = hid_dll.HidUart_SetUartConfig
    HidUart_SetTimeouts   = hid_dll.HidUart_SetTimeouts
    HidUart_FlushBuffers  = hid_dll.HidUart_FlushBuffers

    HID_UART_SUCCESS = 0
    HID_UART_DEVICE = ctypes.c_void_p
    VID = 0x10C4  # 4292 in decimal
    PID = 0x8805  # 34869 in decimal

    def check_success(ret, msg=""):
        if ret != HID_UART_SUCCESS:
            raise IOError(f"{msg} (errcode={ret})")

    # 1) Find & open device
    num = ctypes.c_ulong(0)
    ret = HidUart_GetNumDevices(ctypes.byref(num), VID, PID)
    check_success(ret, "HidUart_GetNumDevices failed")

    if num.value == 0:
        raise IOError("No M2000 USB HID device found")

    dev_handle = HID_UART_DEVICE()
    ret = HidUart_Open(ctypes.byref(dev_handle), device_index, VID, PID)
    check_success(ret, "HidUart_Open failed")

    # Configure the M2000 side for 115200 8N1 w/RTS-CTS
    ret = HidUart_SetUartConfig(
        dev_handle,
        ctypes.c_ulong(115200), # Baud
        ctypes.c_ubyte(8),      # Data bits
        ctypes.c_ubyte(0),      # Parity=NONE
        ctypes.c_ubyte(0),      # Stopbits=1
        ctypes.c_ubyte(2)       # FlowControl=2 => RTS/CTS
    )
    check_success(ret, "HidUart_SetUartConfig failed")

    # Set read/write timeouts in ms
    ret = HidUart_SetTimeouts(dev_handle, 500, 500)
    check_success(ret, "HidUart_SetTimeouts failed")

    # Flush
    ret = HidUart_FlushBuffers(dev_handle, True, True)
    check_success(ret, "HidUart_FlushBuffers failed")

    # Helper for writing
    def usb_write(cmd_string):
        # M2000 expects ASCII lines, typically ending in \n
        out = (cmd_string + "\n").encode('ascii')
        written = ctypes.c_ulong(0)
        retw = HidUart_Write(dev_handle, out, len(out), ctypes.byref(written))
        check_success(retw, "HidUart_Write failed")
        if written.value != len(out):
            raise IOError("Not all bytes written")

    # Helper for reading a line
    def usb_read_line(timeout_s=1.0):
        import time
        start = time.time()
        import collections
        line_buf = bytearray()
        chunk_size = 256
        tmp = (ctypes.c_ubyte * chunk_size)()
        bytes_read = ctypes.c_ulong(0)

        while True:
            # Timeout check
            if (time.time() - start) > timeout_s:
                raise TimeoutError("usb_read_line timed out waiting for LF")

            retr = HidUart_Read(dev_handle, tmp, chunk_size, ctypes.byref(bytes_read))
            check_success(retr, "HidUart_Read failed")

            if bytes_read.value:
                for i in range(bytes_read.value):
                    line_buf.append(tmp[i])
                if b'\n' in line_buf:
                    break
            else:
                time.sleep(0.01)

        # Split at first newline
        return line_buf.split(b'\n', 1)[0].decode('ascii').strip()

    try:
        # 2) Clear interface
        usb_write("*CLS")
        time.sleep(0.1)

        # (Optional) 3) Lock out front panel
        if lock_front_panel:
            usb_write("LOCKOUT")
            time.sleep(0.1)

        # 4) Request ID
        usb_write("*IDN?")
        resp_line = usb_read_line(timeout_s=1.0)
        print("[USB] Raw IDN response:", resp_line)

        fields = resp_line.split(',')
        print("[USB] Parsed IDN fields:")
        for i, f in enumerate(fields, start=1):
            print(f"  Field{i} = {f}")

        # Done. Optionally revert to local:
        # usb_write("LOCAL")

    except Exception as ex:
        print("USB HID Error:", ex)
    finally:
        # Close the device
        if dev_handle:
            HidUart_Close(dev_handle)


###########################
# Main demo of all 3 in one
###########################
if __name__ == "__main__":

    print("==== RS232 Demo ====")
    init_and_read_idn_rs232(
        port_name="COM3",
        baud_rate=115200,
        lock_front_panel=False
    )

    print("\n==== LAN Demo ====")
    init_and_read_idn_lan(
        ip_address="192.168.1.100", 
        port=10733,
        lock_front_panel=False
    )

    print("\n==== USB (HID) Demo ====")
    init_and_read_idn_usb(
        device_index=0,
        lock_front_panel=False
    )

    print("\nDone. (Adjust code as needed for your environment.)")
Explanation of Key Points
Remote Enable
In the M2000 series, as soon as you send any valid command (e.g., *CLS or *IDN?), the instrument goes into REMOTE state. There is no special “REMOTE ON” command.

Locking Out the Front Panel
If you want to ensure an operator cannot locally change instrument settings, send:

Copy code
LOCKOUT
If you later want to unlock from software, send:

sql
Copy code
LOCAL
*IDN? Response
Typically returns up to six comma-separated fields. For example:

Copy code
Vitrek,M2000/EN,12345,2,0,49
Breaking down:

Vitrek (manufacturer)
M2000/EN (model plus installed options)
12345 (serial number)
2 (firmware major)
0 (firmware minor)
49 (firmware build)
Channels
If you have 3 channels, you can read them (for example, voltages) like:

ruby
Copy code
READ? VOLTS:CH1, VOLTS:CH2, VOLTS:CH3
and parse the CSV response.

Syntax for “init”

Send *CLS to clear interface (flush errors).
(Optional) LOCKOUT.
Send *IDN?.
Read/parse response.
RS232

Must have null-modem (crossed TX/RX, plus handshake lines) cable.
Must set rtscts = True and dtr = True in pyserial if the M2000 is configured for RTS/CTS hardware handshake.
Terminate commands with \n or \r\n.
LAN

Connect standard Ethernet cable.
M2000 listens on port 10733.
Only one TCP connection allowed at a time.
Use normal Python socket calls.
USB (HID)

The M2000 enumerates as a “Vendor-Specific HID” with VID=0x10C4 (4292) and PID=0x8805 (34869).
Must use the Silicon Labs DLL calls or an equivalent approach.
The code above uses ctypes to load SLABHIDtoUART.dll.
That’s it! Adjust the code for your port names, IP addresses, or device index as needed, and you have a working script that sets the M2000 into REMOTE, (optionally) locks out the front panel, and queries the ID string. You can then extend it to do any other measurements or configuration on your 3-channel APSM2000.






You said:
i am using an rs232 to usb converter
ChatGPT
RS232 to USB Converter Setup
Thought for 1m 55s
Below is a concise Python example showing how to talk to your APSM2000 via RS232, even if your PC only has USB. In this scenario, you have a USB-to-RS232 adapter cable plugged into the APSM2000’s 9-pin serial port on one side, and a USB port on your computer on the other side.

Key points about USB–RS232 adapters

Install drivers for the adapter so your OS assigns it a COM port (e.g., COM4, COM5, etc. on Windows, or /dev/ttyUSB0, /dev/ttyUSB1 on Linux).
Ensure the handshaking lines and wiring are correct: the M2000 requires DTR, CTS, and RTS lines if it’s set for RTS/CTS handshaking.
Because some USB–serial adapters have internal buffering or latency, you may need small delays or maximum 64-character bursts if you see corruption at high baud rates.
Minimal Python Script (RS232 via USB-to-Serial Adapter)
python
Copy code
import time
import serial  # Requires: pip install pyserial

def init_and_read_idn_rs232(
    port_name="COM4", 
    baud_rate=115200, 
    lock_front_panel=False
):
    """
    Example of communicating with the M2000 (APSM2000) via a USB-to-RS232 adapter.
    1) Opens the serial port (assigned by OS).
    2) Sends *CLS to clear interface.
    3) (Optionally) LOCKOUT to prevent front-panel changes.
    4) Requests *IDN?.
    5) Prints and parses the returned ID string.
    6) Closes the serial port.
    
    Adjust 'port_name' to match your system's COM port.
    """
    ser = serial.Serial()
    ser.port = port_name
    ser.baudrate = baud_rate
    # 8N1, no parity, 1 stop bit
    ser.bytesize = serial.EIGHTBITS
    ser.parity   = serial.PARITY_NONE
    ser.stopbits = serial.STOPBITS_ONE
    ser.timeout  = 1.0  # seconds read timeout

    # If the M2000 is configured for hardware flow control (RTS/CTS):
    ser.rtscts = True
    # DTR must be asserted so the M2000 sees an active controller:
    ser.dtr = True

    try:
        ser.open()
        print(f"Opened {port_name} at {baud_rate} baud.")

        # 1) Clear interface / flush errors:
        ser.write(b"*CLS\n")
        time.sleep(0.1)

        # 2) (Optional) Lock out the front panel
        if lock_front_panel:
            ser.write(b"LOCKOUT\n")
            time.sleep(0.1)

        # 3) Request ID
        ser.write(b"*IDN?\n")
        response = ser.readline().decode('ascii', errors='replace').strip()
        print("Raw *IDN? response:", response)

        # Parse the comma-separated fields
        fields = response.split(',')
        # Typically up to 6 fields: manufacturer, model(+options), serial#, fw_major, fw_minor, fw_build
        print("Parsed fields:")
        for i, f in enumerate(fields, start=1):
            print(f"  Field{i} = {f}")

        # If you want to revert to local from software (unlock front panel):
        # ser.write(b"LOCAL\n")

    except serial.SerialException as e:
        print("Serial error:", e)
    except Exception as e:
        print("General exception:", e)
    finally:
        if ser.is_open:
            ser.close()
            print(f"Closed {port_name}")

if __name__ == "__main__":
    # Adjust the COM port name and baud rate to match your system & M2000 config
    init_and_read_idn_rs232(port_name="COM4", baud_rate=115200, lock_front_panel=False)
How to Run
Install pyserial if you don’t have it:
bash
Copy code
pip install pyserial
Plug in your USB–RS232 adapter, note which COM port appears in your Device Manager (on Windows) or which /dev/ttyUSB# you see on Linux.
Update the port_name in the script to the correct port (for example, "COM4" on Windows or "/dev/ttyUSB0" on Linux).
Confirm the APSM2000 is configured to the same baud rate and RTS/CTS handshake (if you have hardware flow control turned on in the M2000).
Run your Python script. You should see the raw *IDN? response in the console.
Tips & Gotchas
Flow Control: If your M2000 is set for Handshake = hardware (RTS/CTS), you must enable rtscts = True in pyserial. If the M2000 is set for “None” handshake, turn off flow control in your code too.
DTR: The M2000 requires DTR to be asserted, so set ser.dtr = True.
Baud Rates: Common rates are 9600, 19200, 57600, 115200. Make sure your script and the M2000 match.
Cables: The M2000’s RS232 port is pinned as a “DTE” device (same as PC). Therefore, you need a null-modem cable or cross-over cable—plus all handshake lines.
Commands: Once you’re connected, you can send any valid command. For example, to read the 3 channels’ voltages:
python
Copy code
ser.write(b"READ? VOLTS:CH1, VOLTS:CH2, VOLTS:CH3\n")
resp = ser.readline().decode('ascii').strip()
print("Voltage response:", resp)
# Typically comma-separated floating-point values: e.g. +1.23456E+01,+2.34567E+01,+3.45678E+01
Multiple Commands: Either separate them with semicolons (;) in a single line or do multiple ser.write(...) calls with short pauses in between.
That’s it! You’re now controlling the APSM2000 over RS232 using a USB–RS232 adapter in Python.






You said:
okay now i need yoy to write all these details to a readme make sure the code segments are seperated so that parts can easily be copied so i can copy for download
ChatGPT
Request for o1 pro mode
Finished thinking
Below is a README-style set of instructions and explanations for using Python to connect to an APSM2000 (M2000 Series) via RS232 (including USB-to-RS232 adapters), LAN (Ethernet), or USB HID. All the key details and code snippets are divided into sections for easy copying. You can save this as a README.md file or similar for reference.

APSM2000 (M2000 Series) Python Communications Guide
This README provides Python examples to:

Initialize communication over:
RS232 (using pyserial), including USB–RS232 adapters
LAN (TCP/IP Sockets)
USB HID (via Silicon Labs DLL calls)
Enter Remote Mode on the M2000 (automatic upon receiving any valid command).
Lock out the front panel (optional).
Retrieve the instrument identification string (*IDN?) and parse it.
(Optional) Read the voltages on 3 channels.
Note

The APSM2000 automatically goes into REMOTE mode as soon as you send any valid command (e.g., *CLS).
If you want to disable local front-panel control, send LOCKOUT.
To return to local/front-panel control from software, send LOCAL.
1) RS232 Communication (Using pyserial)
Hardware & Driver Setup
If your PC has a physical RS232 port, you can connect a null-modem (crossover) cable (with full handshake lines) directly to the APSM2000.
If your PC only has USB ports, use a USB–RS232 adapter that provides a COM port in your OS.
Install any needed drivers for the adapter so you get a COM port (e.g. COM3, COM4, etc. in Windows; /dev/ttyUSB0 on Linux).
On the APSM2000 side, ensure Handshake=RTS/CTS (if hardware flow control is used) and match the baud rate and handshaking in your script.
Minimal Python Code
python
Copy code
import time
import serial  # pip install pyserial

def init_and_read_idn_rs232(port_name="COM4", baud_rate=115200, lock_front_panel=False):
    """
    Example of communicating with the APSM2000 (M2000 Series) via RS232 (or USB–RS232 adapter).
    1) Opens the serial port (assigned by OS).
    2) Sends *CLS to clear interface.
    3) (Optionally) LOCKOUT to prevent front-panel changes.
    4) Requests *IDN?.
    5) Prints and parses the returned ID string.
    6) Closes the serial port.
    """
    ser = serial.Serial()
    ser.port = port_name
    ser.baudrate = baud_rate

    # 8 data bits, no parity, 1 stop bit
    ser.bytesize = serial.EIGHTBITS
    ser.parity   = serial.PARITY_NONE
    ser.stopbits = serial.STOPBITS_ONE
    ser.timeout  = 1.0  # seconds read timeout

    # If APSM2000 is configured for hardware flow control:
    ser.rtscts = True
    # Assert DTR so APSM2000 recognizes a controller is present:
    ser.dtr = True

    try:
        ser.open()
        print(f"Opened {port_name} at {baud_rate} baud.")

        # Clear interface
        ser.write(b"*CLS\n")
        time.sleep(0.1)

        # (Optional) Lock out front panel
        if lock_front_panel:
            ser.write(b"LOCKOUT\n")
            time.sleep(0.1)

        # Request ID
        ser.write(b"*IDN?\n")
        response = ser.readline().decode('ascii', errors='replace').strip()
        print("Raw *IDN? response:", response)

        # Parse the comma-separated fields
        fields = response.split(',')
        print("Parsed *IDN? fields:")
        for i, f in enumerate(fields, start=1):
            print(f"  Field{i} = {f}")

        # Example of reading 3-channel voltages:
        # ser.write(b"READ? VOLTS:CH1, VOLTS:CH2, VOLTS:CH3\n")
        # volt_resp = ser.readline().decode('ascii').strip()
        # print("3-Ch Voltage response:", volt_resp)

        # Revert to local if you want to unlock panel:
        # ser.write(b"LOCAL\n")

    except serial.SerialException as e:
        print("Serial error:", e)
    except Exception as e:
        print("General exception:", e)
    finally:
        if ser.is_open:
            ser.close()
            print(f"Closed {port_name}")

if __name__ == "__main__":
    init_and_read_idn_rs232(port_name="COM4", baud_rate=115200, lock_front_panel=False)
Run:

pip install pyserial
Update port_name to match your system (e.g. "COM4" or "/dev/ttyUSB0").
Ensure the APSM2000’s serial settings (baud rate, handshake) match.
Execute the Python script.
2) LAN (Ethernet) Communication
Network Setup
Connect an Ethernet cable to the APSM2000 RJ45 port.
Ensure it has a valid IP address (via DHCP or manual).
APSM2000 listens on TCP port 10733. Only one connection allowed at a time.
Minimal Python Code
python
Copy code
import socket
import time

def init_and_read_idn_lan(ip_address="192.168.1.100", port=10733, lock_front_panel=False):
    """
    Opens a TCP socket to the APSM2000 at IP:port.
    1) Clears interface.
    2) (Optionally) LOCKOUT the front panel.
    3) Requests *IDN?.
    4) Prints ID string.
    5) Closes connection.
    """
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(2.0)  # 2 second timeout
    try:
        print(f"Connecting to {ip_address}:{port} ...")
        s.connect((ip_address, port))
        print("Connected.")

        # Clear interface
        s.sendall(b"*CLS\n")
        time.sleep(0.1)

        if lock_front_panel:
            s.sendall(b"LOCKOUT\n")
            time.sleep(0.1)

        # Request ID
        s.sendall(b"*IDN?\n")
        
        response_buffer = []
        while True:
            chunk = s.recv(4096)
            if not chunk:
                break
            response_buffer.append(chunk)
            if b"\n" in chunk:
                # Found the newline terminator
                break

        raw_response = b"".join(response_buffer).decode('ascii').strip()
        print("Raw *IDN? response:", raw_response)

        fields = raw_response.split(',')
        print("Parsed *IDN? fields:")
        for i, f in enumerate(fields, start=1):
            print(f"  Field{i} = {f}")

        # Example: read 3-channel voltages
        # s.sendall(b"READ? VOLTS:CH1, VOLTS:CH2, VOLTS:CH3\n")
        # resp_data = s.recv(4096).decode('ascii').strip()
        # print("3-ch voltage response:", resp_data)

        # Optionally revert to local:
        # s.sendall(b"LOCAL\n")

    except socket.timeout:
        print("Socket timed out.")
    except Exception as ex:
        print("LAN Error:", ex)
    finally:
        s.close()
        print("Socket closed.")

if __name__ == "__main__":
    init_and_read_idn_lan("192.168.1.100", 10733, lock_front_panel=False)
Run:

Ensure APSM2000 IP is correct.
Adjust ip_address in the script.
Run the script. You should see the ID string.
3) USB HID Communication (Using Silicon Labs DLLs)
Hardware & Driver Setup
Use a USB A–B cable from the APSM2000 to your PC.
The APSM2000 enumerates as a Vendor-Specific HID (VID=0x10C4, PID=0x8805). No vendor driver is usually required on Windows.
But you must use the Silicon Labs library (e.g., SLABHIDtoUART.dll) or another HID library to talk to the device.
Minimal Python Code
python
Copy code
import ctypes
import time
import os

def init_and_read_idn_usb(device_index=0, lock_front_panel=False):
    """
    Opens USB HID connection to APSM2000 using the Silicon Labs HID DLL.
    1) Clears interface.
    2) (Optionally) LOCKOUT the front panel.
    3) Requests *IDN?.
    4) Prints ID string.
    5) Closes device.
    """
    # Adjust path to the DLLs
    dll_folder = os.path.abspath(".")
    hid_dll_path = os.path.join(dll_folder, "SLABHIDtoUART.dll")

    # Load the DLL
    hid_dll = ctypes.WinDLL(hid_dll_path)

    # Common function prototypes
    HidUart_GetNumDevices = hid_dll.HidUart_GetNumDevices
    HidUart_Open = hid_dll.HidUart_Open
    HidUart_Close = hid_dll.HidUart_Close
    HidUart_Read = hid_dll.HidUart_Read
    HidUart_Write = hid_dll.HidUart_Write
    HidUart_SetUartConfig = hid_dll.HidUart_SetUartConfig
    HidUart_SetTimeouts = hid_dll.HidUart_SetTimeouts
    HidUart_FlushBuffers = hid_dll.HidUart_FlushBuffers

    HID_UART_SUCCESS = 0
    HID_UART_DEVICE = ctypes.c_void_p
    VID = 0x10C4  # 4292
    PID = 0x8805  # 34869

    def check_success(ret, msg=""):
        if ret != HID_UART_SUCCESS:
            raise IOError(f"{msg} (errcode={ret})")

    # Find device
    num = ctypes.c_ulong(0)
    ret = HidUart_GetNumDevices(ctypes.byref(num), VID, PID)
    check_success(ret, "HidUart_GetNumDevices failed")

    if num.value == 0:
        raise IOError("No M2000 USB HID device found")

    dev_handle = HID_UART_DEVICE()
    ret = HidUart_Open(ctypes.byref(dev_handle), device_index, VID, PID)
    check_success(ret, "HidUart_Open failed")

    # Configure 115200, 8N1, RTS/CTS
    ret = HidUart_SetUartConfig(
        dev_handle,
        ctypes.c_ulong(115200),  # baud
        ctypes.c_ubyte(8),       # data bits
        ctypes.c_ubyte(0),       # parity=none
        ctypes.c_ubyte(0),       # stopbits=1
        ctypes.c_ubyte(2)        # flow control=RTS/CTS
    )
    check_success(ret, "HidUart_SetUartConfig failed")

    # Set read/write timeouts in ms
    ret = HidUart_SetTimeouts(dev_handle, 500, 500)
    check_success(ret, "HidUart_SetTimeouts failed")

    # Flush
    ret = HidUart_FlushBuffers(dev_handle, True, True)
    check_success(ret, "HidUart_FlushBuffers failed")

    # Helper write function
    def usb_write(cmd_string):
        # M2000 expects ASCII lines, end with "\n"
        out = (cmd_string + "\n").encode('ascii')
        written = ctypes.c_ulong(0)
        ret_write = HidUart_Write(dev_handle, out, len(out), ctypes.byref(written))
        check_success(ret_write, "HidUart_Write failed")
        if written.value != len(out):
            raise IOError("Not all bytes written")

    # Helper read line function
    def usb_read_line(timeout_s=1.0):
        start = time.time()
        line_buf = bytearray()
        chunk_size = 256
        tmp = (ctypes.c_ubyte * chunk_size)()
        bytes_read = ctypes.c_ulong(0)

        while True:
            if (time.time() - start) > timeout_s:
                raise TimeoutError("usb_read_line timed out")

            ret_read = HidUart_Read(dev_handle, tmp, chunk_size, ctypes.byref(bytes_read))
            check_success(ret_read, "HidUart_Read failed")

            if bytes_read.value:
                for i in range(bytes_read.value):
                    line_buf.append(tmp[i])
                if b'\n' in line_buf:
                    break
            else:
                time.sleep(0.01)

        return line_buf.split(b'\n', 1)[0].decode('ascii').strip()

    try:
        # Clear interface
        usb_write("*CLS")

        # (Optional) Lock front panel
        if lock_front_panel:
            usb_write("LOCKOUT")

        # *IDN?
        usb_write("*IDN?")
        idn_line = usb_read_line(timeout_s=1.0)
        print("Raw *IDN? response:", idn_line)

        fields = idn_line.split(',')
        print("Parsed *IDN? fields:")
        for i, f in enumerate(fields, start=1):
            print(f"  Field{i} = {f}")

        # Example: read channel voltages
        # usb_write("READ? VOLTS:CH1, VOLTS:CH2, VOLTS:CH3")
        # volt_line = usb_read_line(timeout_s=1.0)
        # print("3-ch voltage response:", volt_line)

        # Optionally go local:
        # usb_write("LOCAL")

    finally:
        if dev_handle:
            HidUart_Close(dev_handle)
            print("Closed USB HID device.")

if __name__ == "__main__":
    init_and_read_idn_usb(device_index=0, lock_front_panel=False)
Run:

Place SLABHIDtoUART.dll (and possibly SLABHIDDevice.dll) in the same folder as your script or in a known path.
Adjust device_index=0 if you have multiple M2000 devices.
Make sure your APSM2000 and your code’s config (baud=115200, etc.) match.
Execute the script and view output.
Common Commands
*CLS: Clears interface registers, flushes errors.
LOCKOUT: Locks the front panel (Remote + no local user changes).
LOCAL: Returns front panel control to the user.
*IDN?: Returns up to six comma-separated fields:
Manufacturer (e.g. Vitrek)
Model (M2000 + optional codes)
Serial Number
Firmware Major Ver
Firmware Minor Ver
Firmware Build
READ? VOLTS:CH1, VOLTS:CH2, VOLTS:CH3: Example to read three channel voltages, comma-separated.
Notes & Tips
Remote Mode: The APSM2000 automatically enters REMOTE when it receives any valid command.
Handshaking (RS232): If the M2000 is set to RTS/CTS, be sure to enable rtscts=True in Python and wire up a null-modem cable that carries RTS, CTS, DTR, DSR, TX, RX, and GND.
USB–RS232 Adapters:
Must assert DTR (ser.dtr=True) or M2000 may discard incoming data.
Some adapters have latency/buffering; you can add small time.sleep(0.05) if you see command corruption.
LAN: Only one TCP socket is allowed at a time. If you lose the connection, wait ~1 minute or power-cycle the M2000 if you cannot reconnect.
USB HID:
The M2000 enumerates as a HID device with VID=4292 (0x10C4) and PID=34869 (0x8805).
You must use the Silicon Labs HID DLL calls or an equivalent approach to talk to the device.
License / Usage
Feel free to adapt or reuse these Python scripts as needed. This README and the code snippets are provided “as-is,” without warranty. Always refer to your APSM2000 (M2000 Series) hardware manual for official details.

Enjoy remote controlling your APSM2000!






You said:
can you write a full script for USB comms i would like the script to stream all the votages ac/dc from all three channels that are being diplayed on the front panel to the terminal to 3 decimal places. all the functions that are displayed on the screen must be streamed to the terminal on the pc so you have the exact display readout to the pc, datalogging must be used and the informaion stored to the pc
ChatGPT
Request for o1 pro mode
Finished thinking
Below is an all-in-one Python script demonstrating how to:

Open a USB HID connection to an APSM2000 (M2000 Series) using the Silicon Labs HID-to-UART DLL.
Continuously stream the AC/DC voltages (and optionally other parameters) from all three channels.
Display the readings in the console with 3 decimal places (matching the front panel style).
Data-log the readings to a CSV file on your PC.
Important Requirements

The APSM2000 enumerates as a vendor-specific HID device (VID=0x10C4, PID=0x8805).
You must have SLABHIDtoUART.dll (and possibly SLABHIDDevice.dll) available to Python, either in the same directory or in your system’s PATH.
The APSM2000’s internal USB–UART bridge must be configured (in the APSM2000) for Baud=115200, 8N1, RTS/CTS (Flow Control), matching this script.
Python 3.x, with the standard library (ctypes, etc.).
Use Ctrl+C (KeyboardInterrupt) to stop the data logging loop.
Script: apms2000_usb_stream.py
python
Copy code
#!/usr/bin/env python3
"""
APSM2000 (M2000 Series) USB HID Streaming Example

- Opens a USB HID connection using the Silicon Labs HID DLL.
- Continuously queries AC/DC voltages (or any other front-panel style measurements) from 3 channels.
- Displays them at 3 decimal places in the console.
- Logs them to a CSV file with timestamps.
- Stops on Ctrl+C.

Requirements:
- 'SLABHIDtoUART.dll' in the same folder or in system PATH.
- APSM2000 configured for 115200 8N1 RTS/CTS on its USB interface.
- Python 3.x
"""

import ctypes
import time
import os
import csv
import sys


#######################################
# 1) USB HID -> M2000 Setup & Helpers
#######################################
# Constants from M2000 documentation / Silicon Labs references
VID = 0x10C4  # 4292 decimal
PID = 0x8805 # 34869 decimal

HID_UART_SUCCESS = 0
HID_UART_DEVICE  = ctypes.c_void_p

# Adjust as needed for your environment
DLL_FOLDER      = os.path.abspath(".")
DLL_FILENAME    = "SLABHIDtoUART.dll"
DLL_PATH        = os.path.join(DLL_FOLDER, DLL_FILENAME)

# The M2000 typically needs 115200, 8N1, RTS/CTS for USB->UART bridging
BAUD_RATE       = 115200
DATA_BITS       = 8
PARITY_NONE     = 0
STOP_BITS_1     = 0
FLOW_CONTROL_RTS_CTS = 2

READ_TIMEOUT_MS  = 500
WRITE_TIMEOUT_MS = 500


#############################
# 2) Load the Silicon Labs DLL
#############################
def load_silabs_dll():
    """
    Loads the SLABHIDtoUART.dll library via ctypes.WinDLL.
    Returns the handle to the DLL and the required function references.
    Raises IOError if DLL not found or a function fails to load.
    """
    # Load the library
    try:
        hid_dll = ctypes.WinDLL(DLL_PATH)
    except OSError as e:
        raise IOError(f"Could not load {DLL_PATH}: {e}")

    # Grab needed functions
    def get_func(name, argtypes=None, restype=ctypes.c_int):
        func = getattr(hid_dll, name, None)
        if not func:
            raise AttributeError(f"Function '{name}' not found in {DLL_FILENAME}")
        func.argtypes = argtypes if argtypes else []
        func.restype  = restype
        return func

    HidUart_GetNumDevices = get_func("HidUart_GetNumDevices", [
        ctypes.POINTER(ctypes.c_ulong),  # numDevices
        ctypes.c_ushort,                 # vid
        ctypes.c_ushort                  # pid
    ])

    HidUart_Open = get_func("HidUart_Open", [
        ctypes.POINTER(HID_UART_DEVICE), # device
        ctypes.c_ulong,                  # deviceIndex
        ctypes.c_ushort,                 # vid
        ctypes.c_ushort                  # pid
    ])

    HidUart_Close = get_func("HidUart_Close", [
        HID_UART_DEVICE
    ])

    HidUart_Read = get_func("HidUart_Read", [
        HID_UART_DEVICE,
        ctypes.c_void_p,
        ctypes.c_ulong,
        ctypes.POINTER(ctypes.c_ulong)
    ])

    HidUart_Write = get_func("HidUart_Write", [
        HID_UART_DEVICE,
        ctypes.c_void_p,
        ctypes.c_ulong,
        ctypes.POINTER(ctypes.c_ulong)
    ])

    HidUart_SetUartConfig = get_func("HidUart_SetUartConfig", [
        HID_UART_DEVICE,
        ctypes.c_ulong, # baudRate
        ctypes.c_ubyte, # dataBits
        ctypes.c_ubyte, # parity
        ctypes.c_ubyte, # stopBits
        ctypes.c_ubyte  # flowControl
    ])

    HidUart_SetTimeouts = get_func("HidUart_SetTimeouts", [
        HID_UART_DEVICE,
        ctypes.c_ulong, # readTimeout_ms
        ctypes.c_ulong  # writeTimeout_ms
    ])

    HidUart_FlushBuffers = get_func("HidUart_FlushBuffers", [
        HID_UART_DEVICE,
        ctypes.c_bool, # flushTransmit
        ctypes.c_bool  # flushReceive
    ])

    return {
        "dll": hid_dll,
        "GetNumDevices": HidUart_GetNumDevices,
        "Open": HidUart_Open,
        "Close": HidUart_Close,
        "Read": HidUart_Read,
        "Write": HidUart_Write,
        "SetUartConfig": HidUart_SetUartConfig,
        "SetTimeouts": HidUart_SetTimeouts,
        "FlushBuffers": HidUart_FlushBuffers
    }


############################
# 3) USB HID M2000 Class
############################
class APSM2000_USB:
    """
    Encapsulates the USB HID connection to the APSM2000,
    providing simple open/close, write, and readline methods.
    """

    def __init__(self, device_index=0):
        self.device_index = device_index
        self.dll_funcs    = load_silabs_dll()
        self.dev_handle   = HID_UART_DEVICE()

    def open(self):
        # 1) Count devices
        num_devices = ctypes.c_ulong(0)
        ret = self.dll_funcs["GetNumDevices"](
            ctypes.byref(num_devices),
            VID,
            PID
        )
        if ret != HID_UART_SUCCESS:
            raise IOError(f"HidUart_GetNumDevices failed (err={ret})")

        if num_devices.value == 0:
            raise IOError("No APSM2000 (M2000) USB HID devices found.")

        # 2) Open device
        ret = self.dll_funcs["Open"](
            ctypes.byref(self.dev_handle),
            self.device_index,
            VID,
            PID
        )
        if ret != HID_UART_SUCCESS:
            raise IOError(f"HidUart_Open failed (err={ret})")

        # 3) Configure UART bridging
        ret = self.dll_funcs["SetUartConfig"](
            self.dev_handle,
            ctypes.c_ulong(BAUD_RATE),
            ctypes.c_ubyte(DATA_BITS),
            ctypes.c_ubyte(PARITY_NONE),
            ctypes.c_ubyte(STOP_BITS_1),
            ctypes.c_ubyte(FLOW_CONTROL_RTS_CTS)
        )
        if ret != HID_UART_SUCCESS:
            raise IOError(f"HidUart_SetUartConfig failed (err={ret})")

        # 4) Timeouts
        ret = self.dll_funcs["SetTimeouts"](self.dev_handle, READ_TIMEOUT_MS, WRITE_TIMEOUT_MS)
        if ret != HID_UART_SUCCESS:
            raise IOError(f"HidUart_SetTimeouts failed (err={ret})")

        # 5) Flush buffers
        ret = self.dll_funcs["FlushBuffers"](self.dev_handle, True, True)
        if ret != HID_UART_SUCCESS:
            raise IOError(f"HidUart_FlushBuffers failed (err={ret})")

        print("APSM2000 USB HID opened successfully.")

    def close(self):
        if self.dev_handle:
            self.dll_funcs["Close"](self.dev_handle)
            print("APSM2000 USB HID closed.")
            self.dev_handle = None

    def write_line(self, command_str):
        """
        Sends a single command line (ASCII) to the M2000,
        automatically appending '\n'.
        """
        if not self.dev_handle:
            raise IOError("Device not open.")

        out_bytes = (command_str + "\n").encode('ascii')
        written   = ctypes.c_ulong(0)
        ret = self.dll_funcs["Write"](
            self.dev_handle,
            out_bytes,
            len(out_bytes),
            ctypes.byref(written)
        )
        if ret != HID_UART_SUCCESS:
            raise IOError(f"HidUart_Write failed (err={ret})")
        if written.value != len(out_bytes):
            raise IOError("HidUart_Write: Incomplete write.")

    def read_line(self, timeout_sec=1.0):
        """
        Reads ASCII data until '\n' is found, or until timeout.
        Returns the line (without trailing newline).
        """
        if not self.dev_handle:
            raise IOError("Device not open.")

        start_time = time.time()
        line_buf   = bytearray()
        chunk_size = 256
        temp_array = (ctypes.c_ubyte * chunk_size)()
        bytes_read = ctypes.c_ulong(0)

        while True:
            # Check for timeout
            if (time.time() - start_time) > timeout_sec:
                raise TimeoutError("read_line timed out waiting for newline.")

            # Attempt read
            ret = self.dll_funcs["Read"](
                self.dev_handle,
                temp_array,
                chunk_size,
                ctypes.byref(bytes_read)
            )
            if ret != HID_UART_SUCCESS:
                raise IOError(f"HidUart_Read failed (err={ret})")

            if bytes_read.value > 0:
                for i in range(bytes_read.value):
                    line_buf.append(temp_array[i])
                # Check for newline
                if b'\n' in line_buf:
                    break
            else:
                time.sleep(0.01)

        # Split at first newline
        line, _, _ = line_buf.partition(b'\n')
        return line.decode('ascii', errors='replace').strip()


############################################
# 4) Main Routine: Stream & Data-Log Example
############################################
def main_stream_voltages_and_log(
    device_index=0,
    output_csv="apms2000_datalog.csv",
    poll_interval=1.0
):
    """
    1) Opens the M2000 over USB HID.
    2) Continuously queries AC/DC voltages from 3 channels (example).
    3) Prints them to the console at 3 decimal places.
    4) Logs them to a CSV file with timestamps.
    5) Stops on Ctrl+C.
    """

    # Here is an example "READ?" command to fetch AC/DC voltages from 3 channels
    # You can add more parameters if needed (e.g. amps, watts, PF, etc.)
    # For instance:
    # READ? VOLTS:CH1:ACDC, VOLTS:CH2:ACDC, VOLTS:CH3:ACDC
    # If you also want current, you'd do:
    # READ? VOLTS:CH1:ACDC, AMPS:CH1:ACDC, ... etc.

    read_command = "READ? VOLTS:CH1:ACDC, VOLTS:CH2:ACDC, VOLTS:CH3:ACDC"

    # Open the connection
    m2000 = APSM2000_USB(device_index=device_index)
    m2000.open()

    # Clear interface
    m2000.write_line("*CLS")
    time.sleep(0.2)

    # Optionally lockout front panel so user can't change settings:
    # m2000.write_line("LOCKOUT")

    # We can also do *IDN? if you want ID info:
    # m2000.write_line("*IDN?")
    # idn_resp = m2000.read_line()
    # print("IDN =", idn_resp)

    # Prepare CSV file
    csvfile = open(output_csv, mode="w", newline="")
    writer  = csv.writer(csvfile)
    # Write CSV header
    writer.writerow([
        "Timestamp (s)",
        "Voltage1 (AC+DC)",
        "Voltage2 (AC+DC)",
        "Voltage3 (AC+DC)"
    ])

    print(f"Logging data to '{output_csv}'. Press Ctrl+C to stop.\n")
    print(f"{'Time(s)':>8} | {'V1':>10} | {'V2':>10} | {'V3':>10}")

    start_time = time.time()
    try:
        while True:
            # Send the READ command
            m2000.write_line(read_command)
            resp_line = m2000.read_line(timeout_sec=2.0)

            # The response is typically comma-separated, e.g.:
            #  +1.23456E+01,+2.34567E+01,+3.45678E+01
            # Convert each to float
            parts = resp_line.split(',')
            if len(parts) < 3:
                # Incomplete data?
                continue

            # Parse floats
            try:
                v1 = float(parts[0])
                v2 = float(parts[1])
                v3 = float(parts[2])
            except ValueError:
                # If parse fails, skip
                continue

            # Current time
            elapsed_s = time.time() - start_time

            # Print with 3 decimal places
            print(f"{elapsed_s:8.2f} | {v1:10.3f} | {v2:10.3f} | {v3:10.3f}")

            # Write to CSV
            writer.writerow([f"{elapsed_s:.2f}", f"{v1:.3f}", f"{v2:.3f}", f"{v3:.3f}"])

            # Flush to ensure data is saved
            csvfile.flush()

            time.sleep(poll_interval)

    except KeyboardInterrupt:
        print("\nUser stopped streaming.")
    except Exception as ex:
        print("Error during streaming:", ex)
    finally:
        # Optionally revert to local if previously locked out
        # m2000.write_line("LOCAL")

        m2000.close()
        csvfile.close()
        print("Closed CSV file, closed M2000.")


######################
# 5) If Run as Script
######################
if __name__ == "__main__":
    # Example usage:
    #   python apms2000_usb_stream.py
    # will create "apms2000_datalog.csv" in the current folder
    # and stream measurements to console.

    # Adjust as necessary
    DEVICE_INDEX   = 0
    OUTPUT_CSV     = "apms2000_datalog.csv"
    POLL_INTERVAL  = 1.0  # seconds

    main_stream_voltages_and_log(
        device_index=DEVICE_INDEX,
        output_csv=OUTPUT_CSV,
        poll_interval=POLL_INTERVAL
    )
How It Works
DLL Loading

We load SLABHIDtoUART.dll (Silicon Labs) via ctypes.WinDLL.
We obtain references to HidUart_Open, HidUart_Write, HidUart_Read, etc.
Open USB HID

APSM2000_USB.open() calls the Silicon Labs functions:
HidUart_GetNumDevices to ensure at least one device is present.
HidUart_Open to open the handle.
HidUart_SetUartConfig to set 115200 8N1 with RTS/CTS.
HidUart_SetTimeouts sets read/write timeouts.
Sending Commands

We use write_line() to send ASCII lines ending in \n.
For example: *CLS clears interface registers, READ? queries measurement data.
Reading Responses

read_line() accumulates bytes until it finds a \n, or times out.
The APSM2000 typically returns comma-separated ASCII fields, e.g. +1.23456E+01,+2.34567E+01,+3.45678E+01.
Continuous Streaming

In main_stream_voltages_and_log(), we send a READ? VOLTS:CHx:ACDC command in a loop.
We parse the response, format it to 3 decimal places, print to console, and also write to a CSV file.
Data Logging

We open a CSV file, write a header row, and each loop iteration writes a new row with (time, v1, v2, v3).
You can import this CSV into spreadsheets, databases, etc.
Exiting

Press Ctrl+C to raise a KeyboardInterrupt, which stops the loop.
We then close the CSV file and the APSM2000 USB handle.
Customizing
Add More Measurements
Change the read_command to fetch more data, for example:
ruby
Copy code
READ? VOLTS:CH1:ACDC, AMPS:CH1:ACDC, WATTS:CH1, ...
Then parse more CSV fields in the response.
Poll Interval
Set poll_interval to define how often to query.
Output Format
Tweak the print formatting or store results in a different file format.
Lockout/Local
If you want to keep users from changing settings from the front panel, send LOCKOUT. Later send LOCAL to restore panel control.
Final Notes
Always ensure your APSM2000 front-panel USB settings match the script’s baud rate (115200), handshake (RTS/CTS), etc.
Place SLABHIDtoUART.dll in the same folder as this script or in a folder on your Windows PATH.
The example is a starting template. You can add error-checking, multi-threading, or advanced logging as needed.
Enjoy capturing your APSM2000’s front-panel readings (AC/DC voltages, or any other measurements) over USB in Python!






You said:
appologies we need a built in method for error handling and logging so that the progam can be debugged
ChatGPT
Request for o1 pro mode
Finished thinking
Below is an all-in-one Python script that:

Opens a USB HID connection to an APSM2000 (M2000 Series) using the Silicon Labs HID-to-UART DLL.
Continuously streams AC/DC voltages (or any parameters you like) from all three channels at a set interval.
Logs data to both the console (with 3 decimal places) and a CSV file.
Incorporates built-in error handling and logging (using Python’s logging module) for easier debugging.
It will print INFO-level logs by default.
If you set the debug=True argument, it will include DEBUG-level details in the logs.
Gracefully handles exceptions (e.g., device errors, parse errors) and logs them, allowing easier debugging.
Important Requirements

APSM2000 enumerates as a vendor-specific HID (VID=0x10C4, PID=0x8805).
SLABHIDtoUART.dll (and possibly SLABHIDDevice.dll) must be accessible (same folder or on system PATH).
The APSM2000’s USB port must be configured for 115200 baud, 8 data bits, RTS/CTS flow control.
Python 3.x with ctypes and the standard library.
On Windows, press Ctrl+C to stop the stream gracefully.
Complete Python Script: apms2000_usb_stream.py
python
Copy code
#!/usr/bin/env python3
"""
APSM2000 (M2000 Series) USB HID Streaming Example with Built-In Logging & Error Handling

Features:
- Opens a USB HID connection using the Silicon Labs HID DLL (SLABHIDtoUART.dll).
- Continuously queries AC/DC voltages from 3 channels, printing to console (3 decimals) and logging to a CSV file.
- Incorporates Python's `logging` module for debug/error tracking.
- Graceful exception handling.

Usage:
  python apms2000_usb_stream.py
    (Creates "apms2000_datalog.csv" with results and prints logs to console.)
"""

import ctypes
import time
import os
import csv
import sys
import logging

####################
# 1) Logging Setup
####################
def setup_logger(debug=False):
    """
    Sets up a global logger with console output.
    If debug=True, sets level to DEBUG; otherwise INFO.
    """
    logger = logging.getLogger("APSM2000_Logger")
    logger.setLevel(logging.DEBUG if debug else logging.INFO)

    # Clear old handlers (if any)
    logger.handlers.clear()
    
    # Create console handler
    ch = logging.StreamHandler(sys.stdout)
    ch.setLevel(logging.DEBUG if debug else logging.INFO)
    
    # Format
    formatter = logging.Formatter(
        fmt="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
        datefmt="%Y-%m-%d %H:%M:%S"
    )
    ch.setFormatter(formatter)
    
    logger.addHandler(ch)
    return logger

# We'll create a module-level logger object.
logger = setup_logger(debug=False)  # Default is INFO-level.


########################################
# 2) Constants for the USB HID interface
########################################
VID = 0x10C4   # 4292 decimal
PID = 0x8805  # 34869 decimal

HID_UART_SUCCESS = 0
HID_UART_DEVICE  = ctypes.c_void_p

DLL_FILENAME    = "SLABHIDtoUART.dll"
READ_TIMEOUT_MS  = 500
WRITE_TIMEOUT_MS = 500

# Typical APSM2000 bridging config:
BAUD_RATE       = 115200
DATA_BITS       = 8
PARITY_NONE     = 0
STOP_BITS_1     = 0
FLOW_CONTROL_RTS_CTS = 2


#######################################
# 3) Load the Silicon Labs HID DLL
#######################################
def load_silabs_dll(dll_folder=None):
    """
    Loads the SLABHIDtoUART.dll via ctypes.WinDLL.
    Returns a dict of references to needed functions.
    Raises IOError/AttributeError on failure.
    """
    if dll_folder is None:
        dll_folder = os.path.abspath(".")
    dll_path = os.path.join(dll_folder, DLL_FILENAME)
    logger.debug(f"Loading DLL from: {dll_path}")

    try:
        hid_dll = ctypes.WinDLL(dll_path)
        logger.debug(f"Successfully loaded: {dll_path}")
    except OSError as e:
        logger.error(f"Could not load {dll_path}: {e}")
        raise IOError(f"Could not load {dll_path}: {e}")

    def get_func(name, argtypes=None, restype=ctypes.c_int):
        func = getattr(hid_dll, name, None)
        if not func:
            msg = f"Function '{name}' not found in {DLL_FILENAME}"
            logger.error(msg)
            raise AttributeError(msg)
        func.argtypes = argtypes if argtypes else []
        func.restype  = restype
        return func

    # Gather the needed functions
    HidUart_GetNumDevices = get_func("HidUart_GetNumDevices", [
        ctypes.POINTER(ctypes.c_ulong),  # numDevices
        ctypes.c_ushort,                 # vid
        ctypes.c_ushort                  # pid
    ])

    HidUart_Open = get_func("HidUart_Open", [
        ctypes.POINTER(HID_UART_DEVICE), # device
        ctypes.c_ulong,                  # deviceIndex
        ctypes.c_ushort,                 # vid
        ctypes.c_ushort                  # pid
    ])

    HidUart_Close = get_func("HidUart_Close", [
        HID_UART_DEVICE
    ])

    HidUart_Read = get_func("HidUart_Read", [
        HID_UART_DEVICE,
        ctypes.c_void_p,
        ctypes.c_ulong,
        ctypes.POINTER(ctypes.c_ulong)
    ])

    HidUart_Write = get_func("HidUart_Write", [
        HID_UART_DEVICE,
        ctypes.c_void_p,
        ctypes.c_ulong,
        ctypes.POINTER(ctypes.c_ulong)
    ])

    HidUart_SetUartConfig = get_func("HidUart_SetUartConfig", [
        HID_UART_DEVICE,
        ctypes.c_ulong, # baudRate
        ctypes.c_ubyte, # dataBits
        ctypes.c_ubyte, # parity
        ctypes.c_ubyte, # stopBits
        ctypes.c_ubyte  # flowControl
    ])

    HidUart_SetTimeouts = get_func("HidUart_SetTimeouts", [
        HID_UART_DEVICE,
        ctypes.c_ulong, # readTimeout_ms
        ctypes.c_ulong  # writeTimeout_ms
    ])

    HidUart_FlushBuffers = get_func("HidUart_FlushBuffers", [
        HID_UART_DEVICE,
        ctypes.c_bool, # flushTransmit
        ctypes.c_bool  # flushReceive
    ])

    return {
        "dll": hid_dll,
        "GetNumDevices": HidUart_GetNumDevices,
        "Open": HidUart_Open,
        "Close": HidUart_Close,
        "Read": HidUart_Read,
        "Write": HidUart_Write,
        "SetUartConfig": HidUart_SetUartConfig,
        "SetTimeouts": HidUart_SetTimeouts,
        "FlushBuffers": HidUart_FlushBuffers
    }


#######################################
# 4) Class: APSM2000 over USB HID
#######################################
class APSM2000_USB:
    """
    Encapsulates the USB HID connection to the APSM2000.
    Provides open/close, write_line, read_line, plus error handling.
    """

    def __init__(self, device_index=0, dll_folder=None):
        self.device_index = device_index
        self.dll_folder   = dll_folder or os.path.abspath(".")
        self.dll_funcs    = load_silabs_dll(self.dll_folder)
        self.dev_handle   = HID_UART_DEVICE()

    def open(self):
        logger.info("Opening APSM2000 USB HID...")
        
        # Check # of devices
        num_devices = ctypes.c_ulong(0)
        ret = self.dll_funcs["GetNumDevices"](
            ctypes.byref(num_devices),
            VID,
            PID
        )
        if ret != HID_UART_SUCCESS:
            err_msg = f"HidUart_GetNumDevices failed (err={ret})"
            logger.error(err_msg)
            raise IOError(err_msg)

        if num_devices.value == 0:
            err_msg = "No APSM2000 USB HID devices found."
            logger.error(err_msg)
            raise IOError(err_msg)

        logger.debug(f"Found {num_devices.value} device(s). Attempting to open index={self.device_index}...")
        
        # Open
        ret = self.dll_funcs["Open"](
            ctypes.byref(self.dev_handle),
            self.device_index,
            VID,
            PID
        )
        if ret != HID_UART_SUCCESS:
            err_msg = f"HidUart_Open failed (err={ret})"
            logger.error(err_msg)
            raise IOError(err_msg)

        # Configure bridging
        logger.debug("Setting UART config (115200 8N1 RTS/CTS)...")
        ret = self.dll_funcs["SetUartConfig"](
            self.dev_handle,
            ctypes.c_ulong(BAUD_RATE),
            ctypes.c_ubyte(DATA_BITS),
            ctypes.c_ubyte(PARITY_NONE),
            ctypes.c_ubyte(STOP_BITS_1),
            ctypes.c_ubyte(FLOW_CONTROL_RTS_CTS)
        )
        if ret != HID_UART_SUCCESS:
            err_msg = f"HidUart_SetUartConfig failed (err={ret})"
            logger.error(err_msg)
            raise IOError(err_msg)

        # Set timeouts
        logger.debug(f"Setting timeouts: read={READ_TIMEOUT_MS} ms, write={WRITE_TIMEOUT_MS} ms")
        ret = self.dll_funcs["SetTimeouts"](
            self.dev_handle,
            READ_TIMEOUT_MS,
            WRITE_TIMEOUT_MS
        )
        if ret != HID_UART_SUCCESS:
            err_msg = f"HidUart_SetTimeouts failed (err={ret})"
            logger.error(err_msg)
            raise IOError(err_msg)

        # Flush
        logger.debug("Flushing HID buffers...")
        ret = self.dll_funcs["FlushBuffers"](
            self.dev_handle,
            True,  # flushTransmit
            True   # flushReceive
        )
        if ret != HID_UART_SUCCESS:
            err_msg = f"HidUart_FlushBuffers failed (err={ret})"
            logger.error(err_msg)
            raise IOError(err_msg)

        logger.info("APSM2000 USB HID opened successfully.")

    def close(self):
        """
        Closes the device if open.
        """
        if self.dev_handle:
            logger.info("Closing APSM2000 USB HID...")
            self.dll_funcs["Close"](self.dev_handle)
            self.dev_handle = None
            logger.info("APSM2000 USB HID closed.")

    def write_line(self, command_str):
        """
        Writes ASCII command with trailing newline.
        """
        if not self.dev_handle:
            raise IOError("Device not open.")
        msg = command_str + "\n"
        out_bytes = msg.encode('ascii')
        written   = ctypes.c_ulong(0)

        ret = self.dll_funcs["Write"](
            self.dev_handle,
            out_bytes,
            len(out_bytes),
            ctypes.byref(written)
        )
        if ret != HID_UART_SUCCESS:
            err_msg = f"HidUart_Write failed (err={ret})"
            logger.error(err_msg)
            raise IOError(err_msg)
        if written.value != len(out_bytes):
            err_msg = "HidUart_Write incomplete write."
            logger.error(err_msg)
            raise IOError(err_msg)

        logger.debug(f"Sent: {command_str}")

    def read_line(self, timeout_sec=1.0):
        """
        Reads ASCII data until newline or timeout.
        Returns the line (str), without trailing newline.
        """
        if not self.dev_handle:
            raise IOError("Device not open.")

        start_time = time.time()
        line_buf   = bytearray()
        chunk_size = 256
        temp_array = (ctypes.c_ubyte * chunk_size)()
        bytes_read = ctypes.c_ulong(0)

        while True:
            # Check for time out
            if (time.time() - start_time) > timeout_sec:
                err_msg = "read_line timed out waiting for newline."
                logger.error(err_msg)
                raise TimeoutError(err_msg)

            # Attempt read
            ret = self.dll_funcs["Read"](
                self.dev_handle,
                temp_array,
                chunk_size,
                ctypes.byref(bytes_read)
            )
            if ret != HID_UART_SUCCESS:
                err_msg = f"HidUart_Read failed (err={ret})"
                logger.error(err_msg)
                raise IOError(err_msg)

            if bytes_read.value > 0:
                for i in range(bytes_read.value):
                    line_buf.append(temp_array[i])
                if b'\n' in line_buf:
                    break
            else:
                time.sleep(0.01)

        # Split at first newline
        line, _, _ = line_buf.partition(b'\n')
        out_line = line.decode('ascii', errors='replace').strip()
        logger.debug(f"Recv: {out_line}")
        return out_line


###########################################################
# 5) Main function: Stream and Data-Log with Error Handling
###########################################################
def stream_voltages_and_log(
    device_index=0,
    output_csv="apms2000_datalog.csv",
    poll_interval=1.0,
    debug=False
):
    """
    1) Opens the M2000 over USB HID.
    2) Continuously queries AC/DC voltages from 3 channels.
    3) Prints them to the console at 3 decimal places.
    4) Logs them to a CSV file with timestamps.
    5) Includes robust error handling and debug logs if debug=True.
    6) Stops on Ctrl+C.
    """

    # Adjust global logger to desired level
    global logger
    logger = setup_logger(debug=debug)

    logger.info("=== Starting APSM2000 USB streaming with built-in logging & error handling ===")
    logger.info(f"Output CSV: {output_csv}")
    logger.info(f"Poll Interval: {poll_interval} s")
    logger.info(f"Debug Mode: {debug}")

    # Example READ? command:
    read_command = "READ? VOLTS:CH1:ACDC, VOLTS:CH2:ACDC, VOLTS:CH3:ACDC"
    
    # Create M2000 object
    m2000 = APSM2000_USB(device_index=device_index)

    try:
        # Open device
        m2000.open()

        # Clear interface, flush errors
        m2000.write_line("*CLS")
        time.sleep(0.2)

        # Optional: lock front panel
        # m2000.write_line("LOCKOUT")

        # Example: query ID
        # m2000.write_line("*IDN?")
        # idn_line = m2000.read_line(timeout_sec=2.0)
        # logger.info(f"IDN Response = {idn_line}")

        # Prepare CSV
        with open(output_csv, mode="w", newline="") as csvfile:
            writer = csv.writer(csvfile)
            # Write header
            writer.writerow(["Timestamp (s)", "Voltage1 (AC+DC)", "Voltage2 (AC+DC)", "Voltage3 (AC+DC)"])
            logger.info(f"CSV logging started: {output_csv}")

            start_time = time.time()
            logger.info("Press Ctrl+C to stop streaming...")

            while True:
                try:
                    # Send read command
                    m2000.write_line(read_command)
                    response_line = m2000.read_line(timeout_sec=2.0)

                    # Split fields
                    parts = response_line.split(',')
                    if len(parts) < 3:
                        # Possibly incomplete response
                        logger.warning(f"Incomplete data from M2000: {response_line}")
                        continue

                    # Parse floats
                    try:
                        v1 = float(parts[0])
                        v2 = float(parts[1])
                        v3 = float(parts[2])
                    except ValueError as ex:
                        logger.warning(f"Could not parse floats from: {response_line} => {ex}")
                        continue

                    elapsed_s = time.time() - start_time

                    # Print to console
                    # Format to 3 decimals
                    print(f"{elapsed_s:8.2f} | {v1:10.3f} | {v2:10.3f} | {v3:10.3f}")

                    # Log to CSV
                    writer.writerow([f"{elapsed_s:.2f}", f"{v1:.3f}", f"{v2:.3f}", f"{v3:.3f}"])
                    csvfile.flush()

                    time.sleep(poll_interval)

                except TimeoutError as tex:
                    logger.error(f"Timeout reading data: {tex}")
                except Exception as genex:
                    logger.error(f"Unexpected error in streaming loop: {genex}", exc_info=True)

    except KeyboardInterrupt:
        logger.info("User pressed Ctrl+C. Stopping streaming.")
    except Exception as e:
        logger.error(f"Critical error: {e}", exc_info=True)
    finally:
        # Optionally revert to local
        # m2000.write_line("LOCAL")

        # Close device
        m2000.close()
        logger.info("=== APSM2000 USB streaming stopped. ===")


######################
# 6) If run as script
######################
if __name__ == "__main__":
    # Default arguments
    DEVICE_INDEX  = 0
    OUTPUT_CSV    = "apms2000_datalog.csv"
    POLL_INTERVAL = 1.0

    # If you want debug logs, change to True
    DEBUG_MODE    = False

    # Start streaming
    stream_voltages_and_log(
        device_index=DEVICE_INDEX,
        output_csv=OUTPUT_CSV,
        poll_interval=POLL_INTERVAL,
        debug=DEBUG_MODE
    )
How This Script Handles Errors & Debugging
Logging Setup

We use a global logger configured by setup_logger(debug=False).
When debug=True, the logger level is set to DEBUG, printing detailed messages for each operation (open, read, parse, etc.).
Otherwise, it’s INFO-level, giving a more concise log.
DLL Loading

If the DLL is missing or a required function is not found, an error is logged at ERROR level, and an exception is raised.
Opening the Device

We check how many devices are present. If none, an IOError is raised.
Any error in HidUart_Open or HidUart_SetUartConfig, etc., is logged.
Reading

Each time we read from the device, we handle potential timeout or parse errors. We log warnings if the data is incomplete or not parseable.
Streaming Loop

If an error occurs mid-loop, we catch it, log details (exc_info=True to show traceback), and continue or break depending on the exception type.
KeyboardInterrupt (Ctrl+C) is handled gracefully.
CSV Logging

Each reading is appended to a CSV file with a timestamp.
We flush after each row so that data is not lost if the program stops unexpectedly.
Exiting

On exit, we close the device properly and log at INFO level.
If you used LOCKOUT at the start, you could optionally send LOCAL to restore front-panel control.
Usage
Place SLABHIDtoUART.dll in the same directory or a known system PATH.
Configure the APSM2000’s USB port for 115200 8N1, RTS/CTS.
Run:
bash
Copy code
python apms2000_usb_stream.py
By default, it writes to apms2000_datalog.csv in the current folder.
It prints the three AC/DC voltages (CH1..CH3) to the console with 3 decimals.
Stop with Ctrl+C.
If you want more debug logs:
bash
Copy code
python apms2000_usb_stream.py
Then edit DEBUG_MODE = True in the script (or pass a flag) so it sets debug=True.
Customizing
Additional Measurements
Instead of just VOLTS:CHn:ACDC, you can also fetch current, power, PF, etc. with a single READ? command, e.g.:

none
Copy code
READ? VOLTS:CH1:ACDC, AMPS:CH1:ACDC, WATTS:CH1, VOLTS:CH2:ACDC, ...
Then parse more fields.

Poll Interval
Adjust poll_interval to control how often to retrieve data.

Error Handling Policy
Right now, if a parse fails, we log a warning and skip that reading. You can choose to raise an error instead.

Logging to a File
If you also want your debug logs in a file, you can add a FileHandler in setup_logger().

That’s it! With this script, you get built-in debugging (log statements at DEBUG or INFO levels), structured error handling, and CSV data-logging for the APSM2000 over USB HID.






You said:
will yjis script run and what functions does it perform
ChatGPT
Request for o1 pro mode
Finished thinking
Below is a summary of what the script does, along with an overview of how to run it and the functions it performs.

Will the Script Run?
Yes—assuming you meet the prerequisites:

Operating System: Typically Windows (because the script loads SLABHIDtoUART.dll via ctypes).
DLL Availability: You must have SLABHIDtoUART.dll (and possibly SLABHIDDevice.dll) in the same folder as the script or in a folder on your Windows PATH.
APSM2000 (M2000):
Must be configured for USB communications at 115200 baud, 8 data bits, RTS/CTS flow control.
The APSM2000 enumerates as a “Vendor-Specific HID” with VID=0x10C4 and PID=0x8805.
Python 3 (3.6+ recommended).
Execution: You run the script from a terminal or command prompt with
bash
Copy code
python apms2000_usb_stream.py
It will attempt to open the USB HID device, communicate with the APSM2000, and start streaming data.
As long as those conditions are met, the script will run.

What Functions Does It Perform?
The script is essentially a complete Python program that handles:

DLL Loading

It loads SLABHIDtoUART.dll using Python’s ctypes.WinDLL, retrieving references to needed Silicon Labs HID–to–UART functions:
HidUart_Open, HidUart_Read, HidUart_Write, HidUart_Close, etc.
APSM2000 USB HID Initialization

It searches for an APSM2000 device with VID=0x10C4 and PID=0x8805.
Opens the device at a specified device index (usually 0 if you have one device).
Configures the device’s internal UART bridging for:
Baud rate = 115200
Data bits = 8
Stop bits = 1
Parity = None
Flow control = RTS/CTS
Sets read/write timeouts (e.g., 500 ms).
Flushes input/output buffers.
Command/Response with the APSM2000

write_line(...): Sends ASCII commands to the APSM2000 ending in \n (for example, *CLS, READ? VOLTS:CH1:ACDC, ...).
read_line(...): Waits until it sees a newline (\n) from the APSM2000’s response (or times out).
It logs or raises errors for partial writes, timeouts, or other I/O failures.
Data Streaming

The script sets up a loop that periodically:
Sends a READ? VOLTS:CH1:ACDC, VOLTS:CH2:ACDC, VOLTS:CH3:ACDC command to read all three channels’ AC+DC voltages.
Receives a line of comma-separated data.
Parses the data into floating-point values.
Displays them in the console formatted to 3 decimal places.
Writes them to a CSV file along with a timestamp.
This continues until you press Ctrl+C (KeyboardInterrupt), or until some critical error occurs.
CSV Logging

The script opens a file named (by default) apms2000_datalog.csv.
It writes a header row.
Each loop iteration appends a new row containing the elapsed time, voltage1, voltage2, and voltage3.
Data is flushed each time so you don’t lose data if the program is interrupted.
Error Handling & Debug Logging

The script uses Python’s built-in logging module.
By default, it logs INFO-level messages (and errors or warnings). If you enable debug=True, it will log additional DEBUG information (including function calls, partial data, etc.).
If a timeout or I/O error occurs, it logs an error message (and you can see a traceback if exc_info=True).
If the data from the instrument is incomplete or unparseable, it logs a warning and continues (rather than crashing).
Optional Front Panel Lock/Unlock

You can send LOCKOUT to disable the front panel controls.
You can send LOCAL to restore local control after streaming.
Summary of the Main Steps
Initialization
Loads DLL, opens device, sets up USB–UART bridging, flushes buffers.
Main Loop
Send command to APSM2000: READ? ...
Read and parse reply.
Print to console in a table-like format.
Write to CSV row.
Sleep for a user-defined poll_interval.
Exit
On Ctrl+C, it stops streaming, closes the CSV file, and closes the device.
Conclusion
Yes, the script will run (on Windows + Python 3 + Silicon Labs DLL + an APSM2000 configured for USB HID).
It opens the USB HID device, streams the AC/DC voltages from all three channels, prints them in the console, and saves them to a CSV file.
It also includes built-in logging for normal and debug modes and basic error handling (timeouts, parse errors, etc.).





You said:
how long are these chats available so i can copy the code
ChatGPT
Request for o1-pro
Thought for 38 seconds
The short answer is: if you're using ChatGPT on the OpenAI website with a registered account, your conversation history is generally saved under your account. You can come back to your chat later (days or even weeks) as long as:

You stay logged into the same account.
ChatGPT’s conversation-history feature remains active for your plan.
However, there is no guaranteed timeframe that chats remain accessible forever. If you log out, clear your account data, or if OpenAI changes its retention policy, you could lose the conversation. Also, some organizations or plan tiers may disable or limit the conversation history feature.

Recommendation

Copy or export any code snippets now to ensure you have a permanent record.
You can also use ChatGPT’s “Export” feature (found under Settings & Beta > Data Controls > Export Chat History) if available.
This way, you won’t be relying on the conversation staying alive indefinitely in ChatGPT’s interface.